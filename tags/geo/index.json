[{"content":"前言 因為工作上的需求，最近接觸到了 GNSS 模組。\n維基百科是這樣說的。\n 衛星導航系統（Global Navigation Satellite System, GNSS）是覆蓋全球的自主地利空間定位的衛星系統，允許小巧的電子接收器確定它的所在位置（經度、緯度和高度），並且經由衛星廣播沿著視線方向傳送的時間信號精確到10米的範圍內。接收機計算的精確時間以及位置，可以作為科學實驗的參考。\n 主要內容 NEO M8N GPS模組  https://www.ruten.com.tw/item/show?21550304728186\n   NEO-M8 Datasheet Page 6\n  NMEA-0183 GGA 表示該語句為 GlobalPositioning System Fix Data(GGA) GPS定位信息\n   \u0026lt;1\u0026gt; \u0026lt;2\u0026gt; \u0026lt;3\u0026gt; \u0026lt;4\u0026gt; \u0026lt;5\u0026gt; \u0026lt;6\u0026gt; \u0026lt;7\u0026gt; \u0026lt;8\u0026gt; \u0026lt;9\u0026gt; \u0026lt;10\u0026gt; \u0026lt;11\u0026gt; \u0026lt;12\u0026gt;     UTC時間 緯度 緯度方向 經度 經度方向 GPS狀態指示 正在使用的衛星數量 HDOP水平精度因子 海平面高度 地球橢球面相對大地水準面的高度 差分GPS信息 差分站ID號    GLL 表示該語句為 Geographic Position(GLL) 地理定位信息\n   \u0026lt;1\u0026gt; \u0026lt;2\u0026gt; \u0026lt;3\u0026gt; \u0026lt;4\u0026gt; \u0026lt;5\u0026gt; \u0026lt;6\u0026gt; \u0026lt;7\u0026gt;     緯度 緯度方向 經度 經度方向 UTC時間 定位狀態 校驗值    GSA 表示該語句為 GPSDOP and Active Satellites(GSA) 當前衛星信息\n   \u0026lt;1\u0026gt; \u0026lt;2\u0026gt; \u0026lt;3\u0026gt; \u0026lt;4\u0026gt; \u0026lt;5\u0026gt; \u0026lt;6\u0026gt;     定位模式 當前狀態 PRN號 PDOP綜合位置精度因子 HDOP水平精度因子 VDOP垂直精度因子    GSV 表示該語句為 GPSSatellites in View(GSV) 可見衛星信息\n   \u0026lt;1\u0026gt; \u0026lt;2\u0026gt; \u0026lt;3\u0026gt; \u0026lt;4\u0026gt; \u0026lt;5\u0026gt; \u0026lt;6\u0026gt; \u0026lt;7\u0026gt;     GSV語句的總數目 當前GSV語句數目 顯示衛星的總數目 衛星的PRN號星號 衛星仰角 衛星鏇角 信噪比    MSS 表示該語句為 GPSSatellites in View(GSV) 可見衛星信息\nRMC 表示該語句為 RecommendedMinimum Specific GPS/TRANSIT Data(RMC) 推薦最小定位信息\n   \u0026lt;1\u0026gt; \u0026lt;2\u0026gt; \u0026lt;3\u0026gt; \u0026lt;4\u0026gt; \u0026lt;5\u0026gt; \u0026lt;6\u0026gt; \u0026lt;7\u0026gt; \u0026lt;8\u0026gt; \u0026lt;9\u0026gt; \u0026lt;10\u0026gt; \u0026lt;11\u0026gt;     定位時UTC時間 狀態 緯度 緯度方向 經度 經度方向 速率,節 方位角 當前UTC日期 磁偏角 磁偏角方向    VTG 表示該語句為TrackMade Good and Ground Speed(VTG) 地面速度信息\n   \u0026lt;1\u0026gt; \u0026lt;2\u0026gt; \u0026lt;3\u0026gt; \u0026lt;4\u0026gt;     真實方向 相對方向 步長 Knots 速率 km/h    GNGGA，GPGGA，BDGGA 傻傻分不清楚 即“混合定位”（多衛星系統）、“GPS定位”、“北斗定位”\n BD,BDS: 北斗二代衛星系統 GP: GPS GL: GLONASS GA: Galileo GN: GNSS, 全球導航衛星系統  GPS模組輸出 連接方式  使用 micro USB 線進行連接\n  指令 筆者是在 MacOS 的環境中進行測試的，只要打開終端機開啟正確的裝置即可。\n1  screen -L /dev/tty.XXXX 9600   硬體識別 在開始接收之後，一開始會顯示該模組的相關資訊:\n U-Blox 的歡迎訊息 硬體版本 在 FLASH 的韌體版本 在 ROM 的韌體版本 型號 通訊協定版本 GNSS 的配置 目前天線的配置 目前天線狀態 FLASH 資訊結構進入點 U-Blox 接收器配置  1 2 3 4 5 6 7 8 9 10 11  $GNTXT,01,01,02,u-blox AG - www.u-blox.com*4E // U-Blox 的歡迎訊息 $GNTXT,01,01,02,HW UBX-M80xx 00080000 *43 // 硬體版本 $GNTXT,01,01,02,EXT CORE 2.01 (75350) Oct 29 2013 16:15:41*5C // 在 FLASH 的韌體版本 $GNTXT,01,01,02,ROM BASE 2.01 (75331) Oct 29 2013 13:28:17*44 // 在 ROM 的韌體版本 $GNTXT,01,01,02,MOD NEO-M8N-0*7A // 型號 $GNTXT,01,01,02,PROTVER 15.00*01 // 通訊協定版本 $GNTXT,01,01,02,GNSS OTP: GPS GLO, SEL: GPS GLO*67 // GNSS配置 $GNTXT,01,01,02,ANTSUPERV=AC SD PDoS SR*3E // 目前天線的配置 $GNTXT,01,01,02,ANTSTATUS=OK*25 // 目前天線狀態 $GNTXT,01,01,02,FIS 0xEF4015 (79189) found*2D // FLASH 資訊結構進入點 $GNTXT,01,01,02,LLC FFFFFFFF-FFFFFFED-FFFFFFFF-FFFFFFFF-FFFFFF69*3E // U-Blox 接收器配置   定位資料 1 2 3 4 5 6 7 8 9 10 11 12  $GNRMC,054539.00,A,2524.04132,N,12130.71568,E,0.059,,200821,,,A*67 $GNVTG,,T,,M,0.059,N,0.109,K,A*39 $GNGGA,054539.00,2524.04132,N,12130.71568,E,1,09,1.82,35.1,M,17.8,M,,*75 $GNGSA,A,3,05,20,29,30,02,13,,,,,,,2.93,1.82,2.29*19 $GNGSA,A,3,87,72,71,,,,,,,,,,2.93,1.82,2.29*1A $GPGSV,4,1,13,02,63,084,43,05,49,332,43,06,26,113,,07,05,051,43*7F $GPGSV,4,2,13,11,52,086,,12,06,223,,13,76,177,21,15,46,226,16*74 $GPGSV,4,3,13,20,45,025,43,24,00,195,,25,02,252,,29,33,309,44*75 $GPGSV,4,4,13,30,21,081,42*44 $GLGSV,2,1,06,65,27,246,,71,36,015,34,72,58,301,28,85,30,146,*6B $GLGSV,2,2,06,86,79,105,,87,28,336,35*62 $GNGLL,2524.04132,N,12130.71568,E,054539.00,A,A*7B   座標轉換 由於模組的輸出是 $ddmm.mmmmm$ 格式，所以我們要再自行轉換為 $dd.dddddd$\n轉換方式: $ dd + \\dfrac {mm.mmmmm}{60} $\n例:\n假設我們收到的資料為 : 2524.04132N, 12130.71568E\n轉換的方式則為 $25 + \\dfrac {24.04132}{60} $, $121 + \\dfrac {30.71568}{60}$\n$ =\u0026gt; 25.4006886667, 121.511928$\n小結 本文僅先了解 GPS 模組基本輸出，尚未進行進一步的測試與研究。\n此外GPS模組輸出/定位資料章節的定位座標並非實際資料。\n參考連結  NEO M8N GPS模組 官方網站 NEO M8N 資料手冊 這應該是關於GPS定位寫得最詳實清晰的文章之一 ","description":"","id":0,"section":"posts","tags":["gps"],"title":"NEO M8N GPS模組","uri":"https://e61983.github.io/2021-08-20-gps-module/"},{"content":"前言 最近開始接觸到跟 GPS 有關的東西，想說順便把地理定位相關的資料整理起來。所以這一篇就這樣誕生啦。\n主要內容 地表上任何一個地理位置都可以用大地基準 ( Datum ) + 座標格式 ( Format ) 來表示。\n在台灣我們常聽到的 TWD67、TWD97、WGS84 就是大地基準。而大地座標、六度分帶(UTM)、二度分帶(TM2) 就是座標格式。\n大地基準  TWD67\n平面基準為1967年之參考橢球體(GRS67)，以南投埔里之虎子山為大地基準。\n橢球參數:長軸 a = 6378160m，扁率 $f = 298.25$ TWD97\n平面基準為1980年之參考橢球體(GRS80)，以八個衛星追蹤站為基準。\n橢球參數:長軸 a = 6378137m，扁率 $f = 298.257222101$ WGS84\n世界大地測量系統（英語：World Geodetic System, WGS），1984年的版本，也稱為 EPSG:4326。透過遍布世界的衛星觀測站觀測到的坐標建立，其精度為1~ 2m。\n地球的質量中心為中心點，加上世界各地的1500個地理座標參考點。\n橢球參數:長軸 a = 6378137m，扁率 $f = 298.257223563$   參考橢球體\n  $ a: 長軸 $\n$ b: 短軸 $\n$ f: 扁率 = \\frac{a-b}{a} $\n座標格式   大地座標\n經、緯度座標。以度、分、秒表示。(僅能表示位置與方向，無法直接表示距離)\n https://en.wikipedia.org/wiki/Local_tangent_plane_coordinates\n    平面座標 (可以表示距離與面績)\n https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system\n    六度分帶 ( Universal Transverse Mercator, UTM)\n 橫麥卡托六度分帶\n    二度分帶 (TM2)\n 橫麥卡托二度分帶\n      座標轉換 TWD97 轉 TWD67 (平面四參數轉換:僅適用台灣本島，最大誤差約2公尺) $X_{67} =X_{97} - 807.8 - AX_{97} - BY_{97}$\n$Y_{67} = Y_{97} + 248.6 - AY_{97} - BX_{97}$\n$A = 0.00001549$\n$B = 0.000006521$\nTWD67 轉 TWD97 (平面四參數轉換:僅適用台灣本島，最大誤差約2公尺) $X_{97} = X_{67} + 807.8 + AX_{67} + BY_{67}$\n$Y_{97} =Y_{67} - 248.6 + AY_{67} + BX_{67}$\n$A = 0.00001549$\n$B = 0.000006521$\n實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) const ( a float64 = 6378137.0 b float64 = 6356752.3142451 lon0 float64 = 121 * math.Pi / 180 k0 float64 = 0.9999 dx float64 = 250000 dy float64 = 0 ) var ( e float64 = 1 - math.Pow(b, 2)/math.Pow(a, 2) e2 float64 = (1 - math.Pow(b, 2)/math.Pow(a, 2)) / (math.Pow(b, 2) / math.Pow(a, 2)) ) func LonLat2TM2(lon, lat float64) (x, y float64) { lon = (lon - math.Floor((lon+180)/360)*360) * math.Pi / 180 lat = lat * math.Pi / 180 V := a / math.Sqrt(1-e*math.Pow(math.Sin(lat), 2)) T := math.Pow(math.Tan(lat), 2) C := e2 * math.Pow(math.Cos(lat), 2) A := math.Cos(lat) * (lon - lon0) M := a * ((1.0-e/4.0-3.0*math.Pow(e, 2)/64.0-5.0*math.Pow(e, 3)/256.0)*lat - (3.0*e/8.0+3.0*math.Pow(e, 2)/32.0+45.0*math.Pow(e, 3)/1024.0)* math.Sin(2.0*lat) + (15.0*math.Pow(e, 2)/256.0+45.0*math.Pow(e, 3)/1024.0)* math.Sin(4.0*lat) - (35.0*math.Pow(e, 3)/3072.0)*math.Sin(6.0*lat)) x = dx + k0*V*(A+(1-T+C)*math.Pow(A, 3)/6+ (5-18*T+math.Pow(T, 2)+72*C-58*e2)*math.Pow(A, 5)/120) y = dy + k0*(M+V*math.Tan(lat)*(math.Pow(A, 2)/2+(5-T+9*C+4*math.Pow(C, 2))*math.Pow(A, 4)/24+ (61-58*T+math.Pow(T, 2)+600*C-330*e2)*math.Pow(A, 6)/720)) return } func TM22LonLat(x, y float64) (lon, lat float64) { x -= dx y -= dy // Calculate the Meridional Arc \tM := y / k0 // Calculate Footprint Latitude \tmu := M / (a * (1.0 - e/4.0 - 3*math.Pow(e, 2)/64.0 - 5*math.Pow(e, 3)/256.0)) e1 := (1.0 - math.Sqrt(1.0-e)) / (1.0 + math.Sqrt(1.0-e)) J1 := (3*e1/2 - 27*math.Pow(e1, 3)/32.0) J2 := (21*math.Pow(e1, 2)/16 - 55*math.Pow(e1, 4)/32.0) J3 := (151 * math.Pow(e1, 3) / 96.0) J4 := (1097 * math.Pow(e1, 4) / 512.0) fp := mu + J1*math.Sin(2*mu) + J2*math.Sin(4*mu) + J3*math.Sin(6*mu) + J4*math.Sin(8*mu) // Calculate Latitude and Longitude  C1 := e2 * math.Pow(math.Cos(fp), 2) T1 := math.Pow(math.Tan(fp), 2) R1 := a * (1 - e) / math.Pow((1-e*math.Pow(math.Sin(fp), 2)), (3.0/2.0)) N1 := a / math.Pow((1-e*math.Pow(math.Sin(fp), 2)), 0.5) D := x / (N1 * k0) // 計算緯度 \tQ1 := N1 * math.Tan(fp) / R1 Q2 := (math.Pow(D, 2) / 2.0) Q3 := (5 + 3*T1 + 10*C1 - 4*math.Pow(C1, 2) - 9*e2) * math.Pow(D, 4) / 24.0 Q4 := (61 + 90*T1 + 298*C1 + 45*math.Pow(T1, 2) - 3*math.Pow(C1, 2) - 252*e2) * math.Pow(D, 6) / 720.0 lat = fp - Q1*(Q2-Q3+Q4) // 計算經度 \tQ5 := D Q6 := (1 + 2*T1 + C1) * math.Pow(D, 3) / 6 Q7 := (5 - 2*C1 + 28*T1 - 3*math.Pow(C1, 2) + 8*e2 + 24*math.Pow(T1, 2)) * math.Pow(D, 5) / 120.0 lon = lon0 + (Q5-Q6+Q7)/math.Cos(fp) lat = (lat * 180) / math.Pi //緯 \tlon = (lon * 180) / math.Pi //經  return } func TWD672TWD97(x, y float64) (x_97, y_97 float64) { const A float64 = 0.00001549 const B float64 = 0.000006521 x_97 = x + 807.8 + A*x + B*y y_97 = y - 248.6 + A*y + B*x return } func TWD972TWD67(x, y float64) (x_67, y_67 float64) { const A float64 = 0.00001549 const B float64 = 0.000006521 x_67 = x - 807.8 - A*x - B*y y_67 = y + 248.6 - A*y - B*x return } // References: // https://www.sunriver.com.tw/taiwanmap/grid_tm2_convert.php func main() { const x_67 float64 = 247342 const y_67 float64 = 2652336 x_97, y_97 := TWD672TWD97(x_67, y_67) fmt.Printf(\u0026#34;TWD67:\\n\u0026#34;) fmt.Printf(\u0026#34;\\t%f, %f\\n\u0026#34;, x_67, y_67) fmt.Printf(\u0026#34;TWD97:\\n\u0026#34;) fmt.Printf(\u0026#34;\\t%f, %f\\n\u0026#34;, x_97, y_97) lon, lat := TM22LonLat(x_97, y_97) fmt.Printf(\u0026#34;LonLat:\\n\u0026#34;) fmt.Printf(\u0026#34;\\t%f, %f\\n\u0026#34;, lon, lat) } /* Output: TWD67: 247342.000000, 2652336.000000 TWD97: 248170.927211, 2652130.097602 LonLat: 120.982026, 23.973876 */   小結 台灣使用的座標表示法，想不到裡面有這麼多歷史可以探究。筆者看完許多資料後，推薦有興趣的同學可以看一看 Taiwan datums ，裡面干貨滿滿 !!\n另外，本最後的實作主要是參考 大胖子與小個子的部落格 的程式，並以 Go 改寫。\n感謝前人的整理與貢獻!\n參考連結  大地座標系統漫談 Taiwan datums 大胖子與小個子的部落格 國立成功大學水工試驗所 坐標系統 ","description":"","id":1,"section":"posts","tags":["geo","gps","go"],"title":"在台灣常見的地理位置表示方式","uri":"https://e61983.github.io/2021-08-19-gps-format/"},{"content":"前言 繼先前建立好基楚的系統後，我們已經加入了 bootlinlabs machine。\n本文會接續之前建立的環境，開始加入自訂的 Image。\n主要內容 Image Image 就是 root filesystem。它會放置於 meta*/recipes*/images/*.bb 中。\nPoky 預設的 Image  core-image-base\n只提供 Console 的環境，並且支援所有硬體功能。 core-image-minimal\n只提供 Console 的環境，並且只滿足開機的須求。 core-image-minimal-dev\n同 core-image-minimal，但又支援額外的開發用工具。 core-image-x11\n提供 X11 圖形化介面。 core-iamge-rt\n同 core-image-minimal, 但額外提供 Real Time 相關工具。  Image 常見的配置項  IMAGE_BASENAME\n輸出的映像檔名稱，預設為 ${PN} IMAGE_INSTALL\n要安裝於此映像檔的 Package / Package groups IMAGE_ROOTFS_SIZE\n最終的 Root filesystem 大小 IMAGE_FEATURES\n提供的特性清單 IMAGE_FSTYPES\n要產生的映像檔種類，例: ext2, ext3, squashfs, cpio, jffs2, ubifs, \u0026hellip; 等。\n可參考 meta/classes/image_types.bbclass IMAGE_LINGUAS\n此映像檔所支援的語言 IMAGE_PKGTYPE\n此映像檔所使用的套件安裝種類，例: deb, rpm, ipk, tar IMAGE_POSTPROCESS_COMMAND\n在最後想要執行的 shell 指令  WIC wic 是一個用來建置可燒寫的映像檔。它可以透過 .wks 或是 .wks.in 來建立分隔區、指定檔案位置。\n相關的配置如:\n1 2  WKS_FILE = \u0026#34;imx-uboot-custom.wks.in\u0026#34; IMAGE_FSTYPES = \u0026#34;wic.bmp wic\u0026#34;   imx-uboot-custom.wks.in:\n1 2 3 4 5 6  part u-boot --source rawcopy --sourceparams=\u0026#34;file=imx-boot\u0026#34; --ondisk sda --no-table --align ${IMX_BOOT_SEEK} part /boot --source bootimg-partition --ondisk sda --fstype=vfat --label boot --active --align 8192 --size 64 part / --source rootfs --ondisk sda --fstype=ext4 --label root --exclude-path=home/ --exclude-path=opt/ --align 8192 part /home --source rootfs --rootfs-dir=${IMAGE_ROOTFS}/home --ondisk sda --fstype=ext4 --label home --align 8192 part /opt --source rootfs --rootfs-dir=${IMAGE_ROOTFS}/opt --ondisk sda --fstype=ext4 --label opt --align 8192 bootloader --ptable msdos   Package Groups 用來將 Package 依其功能進行分類。通常我們可以在 meta*/recipes-core/packagegroups/ 找到，它們會是以 packagegroup- 做為前綴來命名。如: packagegroup-core-boot，packagegroup-core-nfs-server。\n實際撰寫時，只要繼承 packagegroup 即可。例:\n1 2 3 4 5 6 7  SUMMARY = \u0026#34;Debugging tools\u0026#34; LICENSE = \u0026#34;MIT\u0026#34; inherit packagegroup RDEPENDS_${PN} = \u0026#34;\\ gdb \\ gdbserver \\ strace\u0026#34;   建立 bootlinlabs-image-minimal 1 2 3 4 5 6 7 8  pushd ./meta-bootlinlabs mkdir -p recipes-image/images echo \u0026#39;IMAGE_INSTALL = \u0026#34;packagegroup-core-boot\u0026#34;\u0026#39; \u0026gt;\u0026gt; recipes-image/images/bootlinlabs-image-minimal.bb echo \u0026#39;inherit core-image\u0026#39; \u0026gt;\u0026gt; recipes-image/images/bootlinlabs-image-minimal.bb echo \u0026#39;\u0026#39; \u0026gt;\u0026gt; recipes-image/images/bootlinlabs-image-minimal.bb echo \u0026#39;IMAGE_INSTALL_append = \u0026#34; dropbear ninvaders\u0026#34;\u0026#39; \u0026gt;\u0026gt; recipes-image/images/bootlinlabs-image-minimal.bb popd bitbake bootlinlabs-image-minimal   更新 NFS 分享目錄\nsudo tar xpf tmp/deploy/images/bootlinlabs/bootlinlabs-image-minimal-stm32mp1.tar.xz -C /nfs_shared/ 重新啟重 STM32MP1\n bootlinlabs-image-minimal\n  小結 參考連結  Customizing Images using Custom bb Files Bootlin/Yocto with STM32 Bootlin/Yocto with STM32 Lab ","description":"","id":2,"section":"posts","tags":["stm32mp1","yocto","linux"],"title":"在 STM32MP1 上使用 Yocto 建置 Linux 系統 4","uri":"https://e61983.github.io/2021-08-12-stm32mp-with-yocto-4/"},{"content":"前言 繼先前建立好基楚的系統後，我們已經加入了 meta-bootlinlabs Layer。\n本文會接續之前建立的環境，開始加入自訂的 Machine。\n主要內容 BSP Layer BSP Layer 是 Layer 的一種，它通常會包含目標機器的硬體配置、Bootloader、Kernel、Display Support。常以 meta-\u0026lt;bsp-name\u0026gt; 命名，裡面會有 machnes 資料夾。\n如果我們想知道該 BSP Layer 它支援了哪些機器，我們可以在該 Layer 中，觀察它的 conf/machine/*.conf。\n目標機器的配置檔會以 MACHINE.conf 命名。\n但更好的方式是，該 BSP Layer 有完善的 README，讓我們可以直接參考。\nMachine 常見的配置項  TARGET_ARCH\n該機器的硬體架構，例: arm, aarch64 PREFERRED_PROVIDER_virtual/kernel\n預設使用的 Kernel MACHINE_FEATURES\n提供的硬體特性清單，例: usbgadget, usbhost, screen, wifi, bluetooth SERIAL_CONSOLES\n要使用的序列埠與通訊速度，它會被傳給Kernel 做為 console 的參數。例: 115200;ttyS0 KERNEL_IMAGETYPE\n要編譯的映像檔種類，例: zImage, uImage  Bootloader 常見的配置項  SPL_BINARY\n如果有 SPL (Secondary Program Loader)，指定此 SPL 的名稱。預設是空字串。 UBOOT_SUFFIX\nUBOOT的後綴，例: img。預設是 bin。 UBOOT_MACHINE\n目前機器所使用的配置檔。 UBOOT_ENTRYPOINT\nBootloader 的進入點。例: 0xC0800000 UBOOT_LOADADDRESS\nBootloader 載入位置。 UBOOT_MAKE_TARGET\nMakefile 的目標，預設是 all  Kernel 常見的配置項 Kernel 的配置也會撰寫在 \u0026lt;machine\u0026gt;.conf 中\n PREFERRED_PROVIDER_virtual/kernel\n指定要使用的 Kerenl Package PREFERRED_VERSION_linux-yocto = \u0026ldquo;5.10%\u0026rdquo;\n指定要使用的版本 SRC_URL\n必須提供 Kernel 配置檔，並命名為 defconfig。 SRC_URL += \u0026quot;file://defconfig\t\\ file://nand-support.cfg\t\\ file://ethernet-support.cfg \\ \u0026quot;   Kernel Metadata 常見的配置項  LINUX_KERNEL_TYPE  standard (預設) tiny preempt-rt   KERNEL_FEATURES\n提供的 Kernel 特性清單  資料夾結構\n bsp/ cfg/ features/\n例: features/smp.scc\nKERNEL_FEATURES += \u0026ldquo;features/smp.scc\u0026rdquo; 1 2 3  define KFEATURE_DESCRIPTION \u0026#34;Enable SMP\u0026#34; kconf hardware smp.cfg patch smp-support.patch    ktypes/ patches/  調整 Kernel 配置 調整 Kernel 配置時，我們可以以提供 defconfig 的方式進行。或是提供 Configure Fragments 進行調整。\n 提供 defconfig 1 2 3 4 5 6 7 8 9 10  # 配置 Kernel bitbake -c kernel_configme linux-yocto # 手動調整 Kernel 選項 bitbake -c menuconfig linux-yocto # 產生 .config bitbake -c savedefconfig linux-yocto # 我們再自行將 .confg 存為 defconfig    提供 Configure Fragments 1 2 3 4 5 6 7 8 9 10 11  # 配置 Kernel bitbake -c kernel_configme linux-yocto # 手動調整 Kernel 選項 bitbake -c menuconfig linux-yocto # 產生 Configure Fragments bitbake -c diffconfig linux-yocto # 確認 Configure Fragments 是否有正確被套用 bitbake -c kernel_configcheck -f linux-yocto     建立 bootlinlabs Machine 我們可以參考 meta-st-stm32mp/conf/machine 的配置進行 bootlinlabs Machine 的建立。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  pushd ../meta-bootlinlabs # 建立 machine 資料夾 mkdir conf/machine # 建立 bootlinlabs 配置檔 echo \u0026#39;require conf/machine/include/st-machine-common-stm32mp.inc\u0026#39; \u0026gt;\u0026gt; conf/machine/bootlinlabs.conf echo \u0026#39;require conf/machine/include/st-machine-providers-stm32mp.inc\u0026#39; \u0026gt;\u0026gt; conf/machine/bootlinlabs.conf echo \u0026#39;\u0026#39; \u0026gt;\u0026gt; conf/machine/bootlinlabs.conf echo \u0026#39;DEFAULTTUNE = \u0026#34;cortexa7thf-neon-vfpv4\u0026#34;\u0026#39; \u0026gt;\u0026gt; conf/machine/bootlinlabs.conf echo \u0026#39;require conf/machine/include/tune-cortexa7.inc\u0026#39; \u0026gt;\u0026gt; conf/machine/bootlinlabs.conf echo \u0026#39;\u0026#39; \u0026gt;\u0026gt; conf/machine/bootlinlabs.conf echo \u0026#39;BOOTSCHEME_LABELS += \u0026#34;trusted\u0026#34;\u0026#39; \u0026gt;\u0026gt; conf/machine/bootlinlabs.conf echo \u0026#39;STM32MP_DT_FILES_DK += \u0026#34;stm32mp157f-dk2\u0026#34;\u0026#39; \u0026gt;\u0026gt; conf/machine/bootlinlabs.conf echo \u0026#39;FLASHLAYOUT_CONFIG_LABELS += \u0026#34;sdcard\u0026#34;\u0026#39; \u0026gt;\u0026gt; conf/machine/bootlinlabs.conf popd   修改 conf/local.conf 內的 MACHINE，並重新編譯。\n1 2  sed -i \u0026#39;s/^MACHINE.*/MACHINE ?= \u0026#34;bootlinlabs\u0026#34;/g\u0026#39; conf/local.conf bitbake core-image-minimal   我們可以在 ${BUILDDIR}/tmp/deploy/images/**bootlinlabs**/ 看到我們所建立的新 Machine。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  $ ls tmp/deploy/images/bootlinlabs/ arm-trusted-firmware bootloader core-image-minimal-bootlinlabs-20210812144202_nand_4_256_multivolume.rootfs.ubi core-image-minimal-bootlinlabs-20210812144202_nand_4_256_multivolume.ubinize.cfg.ubi core-image-minimal-bootlinlabs-20210812144202_nand_4_256.rootfs.ubi core-image-minimal-bootlinlabs-20210812144202_nand_4_256.rootfs.ubifs core-image-minimal-bootlinlabs-20210812144202_nand_4_256.ubinize.cfg.ubi core-image-minimal-bootlinlabs-20210812144202.rootfs.ext4 core-image-minimal-bootlinlabs-20210812144202.rootfs.manifest core-image-minimal-bootlinlabs-20210812144202.rootfs.tar.xz core-image-minimal-bootlinlabs-20210812144202.testdata.json core-image-minimal-bootlinlabs.ext4 core-image-minimal-bootlinlabs.manifest core-image-minimal-bootlinlabs_nand_4_256_multivolume.ubi core-image-minimal-bootlinlabs_nand_4_256_multivolume.ubinize.cfg.ubi core-image-minimal-bootlinlabs_nand_4_256.ubi core-image-minimal-bootlinlabs_nand_4_256.ubifs core-image-minimal-bootlinlabs_nand_4_256.ubinize.cfg.ubi core-image-minimal-bootlinlabs.tar.xz core-image-minimal-bootlinlabs.testdata.json flashlayout_core-image-minimal kernel scripts   Distro Layer 通常 Distro Layer 會包含 Libc，initialization script, splash screen, \u0026hellip; 等, 相關的配置會記錄在 conf/distro/\u0026lt;distro\u0026gt;.conf 中。\n在 \u0026lt;distro\u0026gt;.conf 中必須包含 DISTRO 變數。例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  require conf/distro/poky.conf DISTRO = \u0026#34;distro\u0026#34; DISTRO_NAME = \u0026#34;distro description\u0026#34; DISTRO_VERSTION = \u0026#34;1.0\u0026#34; MAINTAINER = \u0026#34;...\u0026#34; # 提供的特性清單 DISTRO_FEATURES = \u0026#34;...\u0026#34; # 提供的特性清單，它同時會作用在 MACHINE_FEATURES COMBINED_FEATURES = \u0026#34;...\u0026#34; # Toolchain TCMODE = \u0026#34;...\u0026#34;   小結 本次實做的部份比較少，重心主要放在瞭解 machine，distro 的配置。\n參考連結  Bootlin/Yocto with STM32 Bootlin/Yocto with STM32 Lab ","description":"","id":3,"section":"posts","tags":["stm32mp1","yocto","linux"],"title":"在 STM32MP1 上使用 Yocto 建置 Linux 系統 3","uri":"https://e61983.github.io/2021-08-12-stm32mp-with-yocto-3/"},{"content":"前言 繼先前建立好基楚的系統後，我們已經可以順利開機，並從 NFS 載入 rootf filesystem。\n本文會接續之前建立的環境，開始加入自製的程式以及自訂的 Layer。\n主要內容 Recipe Recipe 是以 \u0026lt;APPLICATION_NAME\u0026gt;_\u0026lt;VERSION\u0026gt;.bb 的方式命名。裡面會包含這個 Package 該如何「穫取源始碼、Patch、編譯、安裝」的方法、它的授權方式以及它的相依套件/Package。\n為了簡化 Recipe 以及避免過多的重複，我們可以將共同的部份撰寫在 \u0026lt;APPLICATION\u0026gt;.inc 並在 Recipe 中引用。\n常見的配置項   DESCRIPTION\n說明、介紹此 Package\n  HOMEPAGE\n如果此 Package 的專案有介紹網站的話，可以寫在此\n  PRIORITY\n預設是: optional\n  SECTION\n這個 Package 的分類。例: console/utils\n  LICENSE\n這個 Package 的授權方式\n  SRC_URL\n這個 Package 源始碼位置\n它的格式為: scheme://\u0026lt;ur\u0026gt;l;param1;param2\nscheme 可以是 https, git, svn, hg, ftp, file, \u0026hellip;\n  SRC_URL[md5sum], SRC_URL[sha256sum]\n源始碼的檢查碼設置。\n例:\n SRC_URI = \u0026ldquo;http://example.com/src.tar.bz2;name=tarball\u0026quot;\nSRC_URI[tarball.md5sum] = \u0026ldquo;97b2c3fb082241ab5c56\u0026hellip;\u0026rdquo;  git scheme:\ngit:\u0026lt;url\u0026gt;;protocol=\u0026lt;protocol\u0026gt;;branch=\u0026lt;branch\u0026gt; http,https,ftp:\nhttps://\u0026lt;url\u0026gt;\n也可以使用一些變數來設置位置，例: ${SOURCEFORGE_MIRROR}/\u0026lt;project-name\u0026gt;/${PN}-${PV}.tar.gz\n詳細資訊可以參考 meta/conf/bitbake.conf      S\n獲取後、解壓縮後的源始碼路目錄。通常會配置為 ${WORKDIR}\n如果是使用 git 來獲取程式碼，則一定要設置成 ${WORKDIR}/git\n  FILESPATH\n本機檔案的搜尋路徑。\n1 2  FILESPATH = \u0026#34;${@base_set_filespath([\u0026#34;${FILE_DIRNAME}/${BP}\u0026#34;, \u0026#34;${FILE_DIRNAME}/${BPN}\u0026#34;,\u0026#34;${FILE_DIRNAME}/files\u0026#34;], d)}\u0026#34;     FILESOVERRIDES\n本機檔案的搜尋路徑。\n1  FILESOVERRIDES = \u0026#34;${TRANSLATED_TARGET_ARCH}:${MACHINEOVERRIDES}:${DISTROOVERRIDES}\u0026#34;     LIC_FILES_CHKSUM\n1 2 3  LIC_FILES_CHKSUM = \u0026#34;file://gpl.txt;md5=393a5ca...\u0026#34; LIC_FILES_CHKSUM = \u0026#34;file://main.c;beginline=3;endline=21;md5=58e...\u0026#34; LIC_FILES_CHKSUM = \u0026#34;file://${COMMON_LICENSE_DIR}/MIT;md5=083...\u0026#34;     DEPENDS\n在編譯時期的相依套件/Package。\n1 2  DEPENDS = \u0026#34;recipe-b\u0026#34; DEPENDS = \u0026#34;recipe-b (\u0026gt;= 1.2)\u0026#34;     RDEPENDS\n在執行時期的相依套件/Package。\n1 2 3  RDEPENDS_${PN} = \u0026#34;recipe-b\u0026#34; RDEPENDS_${PN} = \u0026#34;recipe-b (\u0026gt; 1.2)\u0026#34;     常見的變數  PN\n表示 Package Name BPN\n移除 PN 的前綴與後綴。例: nativesdk- 或是 -native。 PV\n表示 Package Version PR\n表示 Package Revision。預設是: r0 BP\n表示 ${BPN}-${PV} WORKDIR\n表示 Recipe 工作時期的目錄 D\n表示安裝時的目標目錄 1 2 3 4 5  do_install() { install -d ${D}${bindir} install -m 0755 hello ${D}${bindir} }     Task 在 Recipe 中有許的預設的 task，我們可以自訂、修改它們來滿足我們的需求。\n do_fetch do_unpack do_patch do_configure do_compile do_install do_package do_rootfs  我們可以使用下列指令來顯示該 Recipe 有哪些 Task\nbitbake \u0026lt;recipe\u0026gt; -c listtasks  加入自訂的 Task 1 2 3 4  do_mkimage() { uboot-mkimage ... } addtask do_mkimage after do_compile before do_install   Example Recipe 下列是一個 Recipe 的範例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  DESCRIPTION = \u0026#34;Hello world program\u0026#34; HOMEPAGE = \u0026#34;http://example.net/hello/\u0026#34; PRIORITY = \u0026#34;optional\u0026#34; SECTION = \u0026#34;examples\u0026#34; LICENSE = \u0026#34;CLOSED\u0026#34; LIC_FILES_CHKSUM = \u0026#34;\u0026#34; FILESOVERRIDES_prepend := \u0026#34;${THISDIR}/${PN}_${PV}:\u0026#34; SRC_URI = \u0026#34; \\ file://main.c \\ file://Makefile \\ \u0026#34; S = \u0026#34;${WORKDIR}\u0026#34; do_configure () { } do_compile () { oe_runmake } do_install () { oe_runmake install \u0026#39;DESTDIR=${D}\u0026#39; }   我們可以透過下列指令來看到編譯時期 pacakge 的配置。\n1  bitbake -e `\u0026lt;package\u0026gt;`   我們也可以使用下列指令來喚出編譯環境進行操作。\n1  bitbake -c devshell `\u0026lt;package\u0026gt;`     擴展 Recipe 通常不建議直接修改上游的配置，但常常我們又會遇到需要調整程式的需求。這時候我們可以使用 Recipe Extension (.bbappend)。\n它的命名方式為 \u0026lt;appliction\u0026gt;_\u0026lt;version\u0026gt;.bbappend\nrecipe-b_%.bbappend:\n 這要的 % 為萬用字元，在此代表任意版本。\n 1 2 3 4  FILESEXTRAPATHS_prepend := \u0026#34;${THISDIR}/files:\u0026#34; SRC_URI += \u0026#34;file://custom-modification-0.patch \\ file://custom-modification-1.patch \\ \u0026#34;   自訂 Virtual Packages 我們可以透過 PROVIDES = \u0026quot;virtual/\u0026lt;package\u0026gt;\u0026quot; 來表示。\nClass 我們可以提出共同的配置，撰寫成 .bbclass 。在不同的 Recipe 要使用時，就可以以 inherit \u0026lt;class\u0026gt; 來使用它。\n常見到地方有 Build System。例: cmake, make, autotools, \u0026hellip;。更多我們可以在 meta/classes 中找到\nBase Class 已包含了 fetch, unpack, compile, \u0026hellip; 等 Task。可以使用 oe_runmake 並透過 EXTRA_OEMAKE 來指定參數。\nKernel Class 用來建置 Linux Kernel 的 Class。它已配置了 PROVIDE，並且可以使用下列幾個變數:\n KERNEL_IMAGETYPE KERNEL_EXTRA_ARGS INITRAMFS_IMAGE  Useradd Class 用來新增系統的使用者。在使用的時候必須指定 USERADD_PACKAGES，詳情可參考 useradd-example.bb。\n我們可以透過 USERADD_PARAM 與 GROUPADD_PARAM 來傳遞參數給 useradd 及 groupadd\n例:\n1 2 3 4 5 6 7 8 9 10 11 12  DESCRIPTION = \u0026#34;useradd class usage example\u0026#34; PRIORITY = \u0026#34;optional\u0026#34; SECTION = \u0026#34;examples\u0026#34; LICENSE = \u0026#34;MIT\u0026#34; SRC_URI = \u0026#34;file://file0\u0026#34; LIC_FILES_CHKSUM = \u0026#34;file://${COREBASE}/meta/files/common-licenses/MIT;md5=0835ade698e0bc...\u0026#34; inherit useradd USERADD_PACKAGES = \u0026#34;${PN}\u0026#34; USERADD_PARAM = \u0026#34;-u 1000 -d /home/user0 -s /bin/bash user0\u0026#34; do_install() { install -m 644 file0 ${D}/home/user0/ chown user0:user0 ${D}/home/user0/file0 }   Layer Layer 是以 meta-\u0026lt;LAYER_NAME\u0026gt; 的方式命名。裡面會包含這個一個或數個 Recipe。\nBitbake 會獲取 ${BUILDDIR}/conf/bblayers.conf 中每個 Layer 的配置，進而開始建置系統。\n所以，如果我們想要加入 Layer 時，必須將其加入至 BBLAYERS 變數中。\nmeta-bootlinlabs 建立 meta-bootlinlabs 並加入 BBLAYERS 中。\n1 2 3  cd ${BUILDDIR} bitbake-layers create-layer -p 7 ../meta-bootlinlabs bitbake-layers add-layer ../meta-bootlinlabs/   加入 recipe-ninvaders 1 2 3 4 5  pushd ../meta-bootlinlabs mkdir -p recipes-ninvaders/ninvaders recipetool create -o recipes-ninvaders/ninvaders/ninvaders_git.bb https://github.com/TheZ3ro/ninvaders popd bitbake ninvaders   筆者在編譯時遇到了下列錯誤，如果有同學也遇到相同的問題，可以進行下列提到的修改。\nERROR: ninvaders-1.0+gitAUTOINC+c6ab4117ba-r0 do_compile: oe_runmake failed\nERROR: ninvaders-1.0+gitAUTOINC+c6ab4117ba-r0 do_compile: Execution of \u0026lsquo;/home/yuan/workspace/yocto-stm32-labs/build/tmp/work/cortexa7t2hf-neon-vfpv4-poky-linux-gnueabi/ninvaders/1.0+gitAUTOINC+c6ab4117ba-r0/temp/run.do_compile.2732811\u0026rsquo; failed with exit code 1:\nmake: *** No rule to make target \u0026lsquo;globals.o\u0026rsquo;, needed by \u0026lsquo;nInvaders\u0026rsquo;. Stop.\nWARNING: exit code 1 from a shell command.\nninvaders_git.bb:\n1 2  - inherit autotools + inherit autotools-brokensep    The problem is most likely that you\u0026rsquo;re not using automake but the\ngenerated recipe (would have been useful to include that) is using the\nautotools class, which assumes correct use of both autoconf and\nautomake. Specifically, your hand-written Makefile doesn\u0026rsquo;t handle\nout-of-tree builds.\nSource: [yocto] Adding nInvaders game package recipe\n  將 ninvaders 加入 root filesystem 中 重新編譯後，記得要更新 NFS 分享目錄\n1 2  echo \u0026#39;IMAGE_INSTALL_append = \u0026#34; ninvaders\u0026#34;\u0026#39; bitbake core-image-miminal   接著重新啟動 STM32MP1 之後，執行 nInvaders\n nInvaders 執行結果\n  小結 因為筆者手邊沒有 Nunchuk ，所以也就沒有進行 Lab 5 了。\n有興趣的同學，再自己玩玩看囉!\n參考連結  OpenEmbedded Layer Index TheZ3ro/ninvaders Bootlin/Yocto with STM32 Bootlin/Yocto with STM32 Lab ","description":"","id":4,"section":"posts","tags":["stm32mp1","yocto","linux"],"title":"在 STM32MP1 上使用 Yocto 建置 Linux 系統 2","uri":"https://e61983.github.io/2021-08-12-stm32mp-with-yocto-2/"},{"content":"前言 手邊有一片很久沒有動過的 STM32MP157。剛好最近工作上需要在 imx8 進行開發。本文會照著 Bootlin 的課程進行實作 [2],一方面了解 Yocto 要如何使用，另一方面順便藉此先練練手。\n主要內容 環境 本文的實作環境是使用 Ubuntu 20.04.2 LTS 做為 Host，使用的網段是在 10.1.100.0/24 內。\n準備 Bootlin 的課程資料 下載 bootlin 課程之 Lab 資料\n1 2 3 4 5 6 7  cd ${HOME} # 下載 Lab 資料 wget https://bootlin.com/doc/training/yocto-stm32/yocto-stm32-labs.tar.xz # 解壓縮 tar xvf yocto-stm32-labs.tar.xz   安裝 Yocto 的相依套件 1  sudo apt install -y bc build-essential chrpath cpio diffstat gawk git python texinfo wget gdisk   筆者在編譯映像檔時，遇到了 openssl/ssl.h' file not found 的問題，所以輸入下列指令進行安裝。\n1  sudo apt install -y libssl-dev     建置 Yocto 環境 1 2 3 4 5 6  pushd ${HOME}/yocto-stm32-labs git clone -b dunfell-23.0.7 git://git.yoctoproject.org/poky.git popd git clone -b dunfell git://git.openembedded.org/meta-openembedded git clone -b dunfell https://github.com/STMicroelectronics/meta-st-stm32mp.git # cd meta-st-stm32mp \u0026amp;\u0026amp; git checkout a95cc1ec39b60a1dc50d0902c91675935959e6d2   初始化 Yocto 環境\n1 2  cd ${HOME}/yocto-stm32-labs source poky/oe-init-build-env   加入 STM32MP1 的 BSP\n1 2 3 4 5 6 7  # pwd  # ${HOME}/yocto-stm32-labs/poky/oe-init-build-env/build # 加入 stm32mp 相關的層 bitbake-layers add-layer ../meta-openembedded/meta-oe bitbake-layers add-layer ../meta-openembedded/meta-python bitbake-layers add-layer ../meta-st-stm32mp   修改 Yocto 的配置檔 1 2  # 修改目標機器 sed -i \u0026#39;s/^MACHINE.*/MACHINE ?= \u0026#34;stm32mp1\u0026#34;/g\u0026#39; conf/local.conf   建置映像檔 1  bitbake core-image-minimal   下列是 conf/local.conf 常會配置的幾個配置項\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  # 下載路徑 DL_DIR # 編譯結果快取 SSTATE_DIR # Bitbake 同時跑多少個 Task BB_NUMBER_THREADS # 編譯時跑多少個執行緒 PARALLEL_MAKE # 目標機器 MACHINE     建置用於 SD Card 的映像檔 1 2 3  ${BUILDDIR}/tmp/deploy/images/stm32mp1/scripts/create_sdcard_from_flashlayout.sh ../flashlayout_core-image-minimal/trusted/FlashLayout_sdcard_stm32mp157f-dk2-trusted.tsv # 產生 *.raw 於 ${BUILDDIR}/tmp/deploy/images/stm32mp1   將映像檔寫入 SD Card 中 1 2 3 4  # 插入 SD Card 到電腦中 sudo dd if=FlashLayout_sdcard_stm32mp157f-dk2-trusted.raw of=/dev/mmcblk0 bs=8M status=progress conv=fdatasync # or  #sudo dd if=FlashLayout_sdcard_stm32mp157f-dk2-trusted.raw | pv -s ${IMAGE_SIZE} | dd of=/dev/mmcblk0 bs=4096 \u0026amp;\u0026amp; sync   測試 接上 ST-LINK 之後，在電腦開啟終端機\n 接上 ST-Link\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14  # 參考自己電腦實際認到的裝置號 screen /dev/${SERIAL_PORT} 115200 # 使用 root 登入 Poky (Yocto Project Reference Distro) 3.1.7 stm32mp1 /dev/ttySTM0 # 結果 # stm32mp1 login: root # root@stm32mp1:~# uname -a # Linux stm32mp1 5.4.56 #1 SMP PREEMPT Wed Aug 5 07:59:52 UTC 2020 armv7l GNU/Linux # root@stm32mp1:~# # 使用 C-a C-k 離開    在STM32MP1 第一個 Linux 系統\n  從 NFS 載入 Root Filesystem 為了在後續的開發中，可以不用一直拔拔插插 SD Card。我們要讓系統在開機後，從 NFS Server 下載 root filesystem。\n建置 NFS 環境 在我們的工作機上，安裝 NFS Server\n1 2 3 4 5 6 7 8 9 10 11  # 安裝 NFS Server sudo apt install -y nfs-kernel-server # 建立 NFS 分享路徑 sudo mkdir /nfs_shared # 配置 NFS Server 設定檔 echo \u0026#34;/nfs_shared *(insecure,rw,sync,no_root_squash,subtree_check)\u0026#34; \u0026gt;\u0026gt; /etc/exports # 啟動 NFS Server sudo systemctl enable nfs-kernel-server \u0026amp;\u0026amp; sudo systemctl restart nfs-kernel-server   解壓縮我們先前建立好的 root filesystem 到 NFS 分享目錄中。\n1 2  # 將先前我們建置好的 root filesystem 解壓縮至我自建立的 /nfs_shared 中 sudo tar xpf ${BUILDDIR}/tmp/deploy/images/stm32mp1/core-image-minimal-stm32mp1.tar.xz -C /nfs_shared/   修改 U-boot 的開機選項 修改 SD Card 內 bootfs 分割區中的 mmc0_extlinux/stm32mp157f-dk2_extlinux.conf，在開機的過程中u-boot 會將參數傳遞給 kernel。有興趣的同學可以參考 nfs/nfsroot.txt\n1  APPEND root=/dev/nfs rw console=ttySTM0,115200 nfsroot=${serverip}:/nfs_shared,vers=3,tcp ip=dhcp:${serverip}:${gateway}:${netmask}:${hostname}:eth0    為什麼是 mmc0_extlinux/stm32mp157f-dk2_extlinux.conf 這個檔案呢 ?\n筆者現階段並沒有深究，相信隨著課程的進行。\n我們會知道的。\n 重新開機之後，系統就會從 NFS 載入 root filesystem 了。\n 從 NFS 載入 rootfilesystem\n  使用 SSH 登入 加入 SSH Server 至系統中 修改 conf/local.conf ，在裡面加上 dropbear Package\n1  echo \u0026#39;IMAGE_INSTALL_append = \u0026#34; dropbear\u0026#34;\u0026#39; \u0026gt;\u0026gt; ${BUILDDIR}/conf/local.conf   重新編譯\n1  bitbake core-image-minimal   依照先前的步驟，重新解壓縮剛建立好的 root filesystem 到 NFS 分享目錄中。\n測試 STM32MP1 重新開機後，在 Host 端使用 ssh 指令進行連接。\n1 2 3 4 5 6 7 8  ssh root@${IP} # 結果 # ssh root@10.1.100.104 # The authenticity of host \u0026#39;10.1.100.104 (10.1.100.104)\u0026#39; can\u0026#39;t be established. # RSA key fingerprint is SHA256:cDpQ47v01ZUkm6GpUG29F+RPOHVV7EzfDA5z/A4bDv4. # Are you sure you want to continue connecting (yes/no/[fingerprint])? yes # Warning: Permanently added \u0026#39;10.1.100.104\u0026#39; (RSA) to the list of known hosts.   更多關於 conf/local.conf  通常會是以大寫表示，如: CONF_VERSION _append:\n在原本設定的 後方 增加新的設定值，如: IMAGE_INSTALL_append = \u0026quot; dropbear\u0026quot; _prepend:\n在原本設定的 前方 增加新的設定值，如: FILESEXTRAPATHS_prepend := \u0026ldquo;${THISDIR}/${PN}\u0026rdquo; _remove:\n用來移除當下設定值中的值，如: IMAGE_INSTALL_remove = \u0026ldquo;i2c-tools\u0026rdquo; _${MACHINE}:\n用來表示，如果當時的 MACHINE 與 _${MACHINE} 相符時，使用這個設定值。\n如: IMAGE_INSTALL_append_beaglebone = \u0026quot; i2c-tools\u0026quot;，當我們的 MACHINE 是 beaglebone 時，才會生效。\n如: IMAGE_INSTALL_beaglebone = \u0026ldquo;busybox i2c-tools\u0026rdquo;，當我們的 MACHINE 是 beaglebone 時，才會生效。  上述的操作也可以使用符號表示\n =\n使用這個變數時，會將其展開。 :=\n立即值。 +=\n與 _append 相同 (要加上空白)。 (盡量避免在 conf/local.conf 中使用) =+\n與 _prepend 相同 (要加上空白)。(盡量避免在 conf/local.conf 中使用) .=\n與 _append 相同 (不用加上空白)。 (盡量避免在 conf/local.conf 中使用) =.\n與 _prepend 相同 (不用加上空白)。 (盡量避免在 conf/local.conf 中使用) ?=\n如果先前給過值的話，使用先前的值。 ??=\n與 ?= 相同，但優先權更低。  虛擬 Package Virtual Package 會以 vitual/命名，但它是不是真的 Package 。\n 假的\n  常見的 virtual pacakge 有\n virtual/bootloader: u-boot, u-boot-ti-staging, \u0026hellip; virtual/kernel: linux-yocto, linux-yocto-tiny, linux-ti-staging, \u0026hellip; virtual/libc: glibc, musl, newlib virtual/xserver: xserver-xorg  選擇 我們可以使用 PREFERRED_PROVIDER 來指定我們想要用的 Package。\n如: PREFERRED_PROVIDER_vritual/kernel ?= \u0026ldquo;linux-ti-staging\u0026rdquo;\n我們可以使用 PREFERRED_VERSION 來指定想使用的 Package 版本。\n如: PREFERRED_VERSION_python = \u0026ldquo;2.7.3\u0026rdquo; 或是 PREFERRED_VERSION_linux-yocto = \u0026ldquo;5.4.%\u0026rdquo;\nRoot Filesystem 我們可以使用 IMAGE_INSTALL 來指定哪些 Packages 要加入 root filesystem 中，並可以使用 RDEPENDS 來指定其相依 Packages. 我們也可以使用 PACKAGE_EXCLUDE 來過慮我們不想要的 Packages。\n小結 我們已經建立了基本的 STM32MP1 Linux 系統開發環境，接下來就要一邊玩 Yocto 一邊探索 STM32MP1 的週邊了。\n參考連結  STM32MP157F-DK2 Bootlin/Yocto with STM32 Bootlin/Yocto with STM32 Lab Wiki - STM32MP1 Distribution Package Kernel Document - nfsroot ","description":"","id":5,"section":"posts","tags":["stm32mp1","yocto","linux"],"title":"在 STM32MP1 上使用 Yocto 建置 Linux 系統","uri":"https://e61983.github.io/2021-08-11-stm32mp-with-yocto/"},{"content":"前言 最近剛好要更新地圖應用。先前是直接使用 Mapbox ，但覺得它的 Marker 操作起來不是很彈性。因緣際會下聽說了 Leaflet ，就來試看看吧。\n維基百科是這樣說的。\n Leaflet是一個開源的JavaScript庫，用於構建Web地圖應用。首次發布於2011年，2它支持大多數移動和桌面平台，支持HTML5和CSS3。\n 主要內容 安裝方式 本文撰寫時會以 CDN 的方式引入 Leaflet.js，實際使用時筆者是會使用套件管理工具進行安裝。\n安裝方式:\n1  yarn add leaflet   使用 CDN 的方式:\n1 2 3 4 5 6 7 8  \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/leaflet@1.7.1/dist/leaflet.css\u0026#34; integrity=\u0026#34;sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==\u0026#34; crossorigin=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;!-- Make sure you put this AFTER Leaflet\u0026#39;s CSS --\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/leaflet@1.7.1/dist/leaflet.js\u0026#34; integrity=\u0026#34;sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==\u0026#34; crossorigin=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   起手式 在網頁中加入\n1  \u0026lt;div id=\u0026#34;map\u0026#34; style=\u0026#34;width:95vw;height:95vh\u0026#34; /\u0026gt;   初始化地圖\n1 2 3 4 5 6  var map = L.map(\u0026#39;map\u0026#39;).setView([34.985851028839406, 135.75788488621308], 10); L.tileLayer(\u0026#39;https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}\u0026#39;, { foo: \u0026#39;bar\u0026#39;, attribution: \u0026#39;\u0026amp;copy; \u0026lt;a href=\u0026#34;https://www.openstreetmap.org/copyright\u0026#34;\u0026gt;OpenStreetMap\u0026lt;/a\u0026gt; contributors\u0026#39;, }).addTo(map);    我們的第一張地圖\n  如果我們想要使用 Mapbox 的圖資，在已取得存取金鑰之後(Access Toekn)，可在建立 titleLayer 時改用下列方式初始化。\n1 2 3 4 5 6 7 8 9 10  var map = L.map(\u0026#39;map\u0026#39;).setView([34.985851028839406, 135.75788488621308], 10); L.tileLayer(\u0026#39;\u0026#39;https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token={accessToken}\u0026#39;,  { attribution: \u0026#39;\u0026amp;copy; \u0026lt;a href=\u0026#34;https://www.mapbox.com/about/maps/\u0026#34;\u0026gt;Mapbox\u0026lt;/a\u0026gt; contributors\u0026#39; maxZoom: 18, zoomOffset: -1, tileSize: 512, id: \u0026#39;mapbox/streets-v11\u0026#39;, accessToken: token }).addTo(map);    使用 Mapbox 圖資\n  如果想要移除預設的 zoom controller 可以在初始化的時候加上 zoomControl: false\n1  var map = L.map(\u0026#39;map\u0026#39;, {zoomControl: false}).setView([34.985851028839406, 135.75788488621308], 10);   加上 Marker 在 Leaflet 中加上 marker 就跟呼吸一樣自然。\n1 2 3  L.marker([35.04074994371372, 135.72932367775914]).addTo(map); L.marker([34.97374817523019, 135.77195253085293]).addTo(map); L.marker([34.99936852552379, 135.7854861479551]).addTo(map);    加上 marker\n  如果想要改變樣式，可以透過 icon 或是 iconDiv 來更改。\n1 2 3 4 5 6 7 8 9 10 11 12  var myIcon = L.icon({ iconUrl: \u0026#39;marker.png\u0026#39;, iconSize: [100, 95], iconAnchor: [22, 94], popupAnchor: [-3, -76], shadowUrl: \u0026#39;my-icon-shadow.png\u0026#39;, shadowSize: [68, 95], shadowAnchor: [22, 94] }); L.marker([34.70432671595862, 135.50096236284378], { icon: myIcon }).addTo(map);   1 2 3 4 5 6 7  var myDivIcon = L.divIcon({ className:\u0026#39;my-div-icon-wrapper\u0026#39;, html:`\u0026lt;div\u0026gt;這是 Div Icon \u0026lt;/div\u0026gt;` }); L.marker([34.68985107822455, 135.5253549268327], { icon: myDivIcon }).addTo(map);   1 2 3 4 5 6  .my-div-icon-wrapper div{ width: 100px; background-color: #060390; color: #eee; text-align: center; }    加上 marker\n  來畫線吧 1 2 3 4 5 6 7 8 9  var latlngs = [ [35.02537491062854, 135.7438607946139], [34.88948810597932, 135.8076289149232], [34.961035819215525, 135.65613226663768], [34.976863645786004, 135.82695459531024], [34.88036360232042, 135.7002729085305], [35.02537491062854, 135.7438607946139], ]; L.polyline(latlngs, {color: \u0026#39;red\u0026#39;}).addTo(map);    來個封印陣吧!\n  群組化並加上控制項 我們可以把想要歸在一起的東西放到同一個群組，這樣在接下來要分層顯示的時候，會更簡便一些。\n讓我們稍微調整一下程式碼。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  ... let layer1 = L.layerGroup([ L.marker([35.04074994371372, 135.72932367775914]), L.marker([34.97374817523019, 135.77195253085293]), L.marker([34.99936852552379, 135.7854861479551]) ]).addTo(map); ... let layer2 = L.layerGroup([ L.marker([34.70432671595862, 135.50096236284378], { icon: myIcon }), L.marker([34.68985107822455, 135.5253549268327], { icon: myDivIcon }) ]).addTo(map); ... let layer3= L.layerGroup([ L.polyline(latlngs, {color: \u0026#39;red\u0026#39;}) ]).addTo(map);   將我們群組化後的 Layer 加入控制項中。\n1 2 3 4 5  let controller = L.control.layers().addTo(map); controller.addOverlay(layer1,\u0026#34;Marker\u0026#34;); controller.addOverlay(layer2,\u0026#34;自定的Marker\u0026#34;); controller.addOverlay(layer3,\u0026#34;封印陣\u0026#34;); controller.expand();    加入控制項\n  補充一下，如果想移除各個 Layer 的話可以透過下列方式，移除\n1 2 3 4 5 6 7 8 9 10  map.value.eachLayer((layer) =\u0026gt; { if (layer instanceof L.Marker) { map.value.removeLayer(layer); } }); // or  layer1.remove();   20210808 新增 - geoJSON Layer 測試資料可以到政府開放資料平台取得。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  let data = {\u0026#34;type\u0026#34;:\u0026#34;FeatureCollection\u0026#34;, \u0026#34;features\u0026#34;: [ \u0026#34;type\u0026#34;:\u0026#34;Feature\u0026#34;,\u0026#34;geometry\u0026#34;:{\u0026#34;type\u0026#34;:\u0026#34;Polygon\u0026#34;,\u0026#34;coordinates\u0026#34;:[[[121.543841724,25.0449066970000,...................... ]]] ]} function onEachFeature(feature, layer) { if (feature.properties \u0026amp;\u0026amp; feature.properties.TOWNNAME) { layer.bindPopup(feature.properties.TOWNNAME); } } L.geoJSON(data, { onEachFeature: onEachFeature, filter: function(feature, layer) { return feature.properties.TOWNNAME == \u0026#39;大安區\u0026#39;; }, style: function(feature) { switch (feature.properties.TOWNNAME) { case \u0026#39;大安區\u0026#39;: return {color: \u0026#34;#00ff00\u0026#34;,weight:1}; default: return {color: \u0026#34;#333333\u0026#34;,weight:1,opacity:0.5 }; } } }).addTo(map);    使用 geolayer\n  成果  小結 使用 Leaflet 之後，不管是在操作 Marker 還是要建立 Path 都變得更加容易了。只能說是相見恨晚!\n參考連結  Leafletjs Migrate Mapbox Static Title API Leaflet-providers preview ","description":"","id":6,"section":"posts","tags":["map","leaflet","geojson"],"title":"使用 Leaflet 地圖","uri":"https://e61983.github.io/2021-08-04-using-leaflet-map/"},{"content":"前言 今年的 COSCUP 因應 COVID-19 疫情，所以以線上直播的方式進行。本篇主要是記錄大會第二天有興趣的議程以及關鍵字。\n主要內容 細談 MySQL Replication 強項 References:  MySQL Replication 主從式架構設定教學 MySQL 主從複製原理  資料庫也可以全年無休啦! 神奇的MySQL HA架構拯救你的資料庫!   MySQL Cluster\n SQL Node 讀資料 Data Node 存資料 Management Node - 用來管理 NDB Cluster    MGM:\n config.ini ndb_mgm    Data/ SQL Node\n /etc/my.conf ndbd    SQL\n systemd start mysqld    Node Group\n  一般是異步\n  ndb 是同步的\n Master 會傳 Log 給 Slave ，確認後會執行動作來進行同步。    References  MySQL Cluster學習筆記  SignalR 整合 LINE，在LIFF裡建立一對一聊天管道   LIFF ( Line Front-end Framework ) SignalR  Group    References:  SignalR  MySQL 8 那麼久了，還沒開始用 window function 嗎？  什麼是 Wndow Function  保留每一列的 Query 結果，但又有聚合的操作結果。       OVER (PARTITION BY contry)\n  { OVER (window_spec) | OVER window_name }\n  Query Rewrite\n  使用 Qemu + Debian Linux 來進行嵌入式系統入門教學    Den U-Boot Linux Kernel Root File System  References:  共筆  MySQL究極防禦工事(全自動化MHA機制)  Proxy SQL Orchestrator 了解 Master - Slave 架構、同步機制  References:  Slide 共筆  初試 Casbin - 快速搭建符合 99% 產品都需要的高彈性可維護之授權控制系統  Authen \u0026amp; Authorization  Authen - 你是誰 Authorization - 你可以做什麼    權限管理方式  ACL (Accuess Control List) RBAC (Role-Base Access Control) Attribute-based access control  Casbin   PML Policy Storage  References:  casbin/casbin ory ory/oathkeeper  MySQL 8.0的新SQL為開發者開啟一片天  Window Function  History  4.1 B-Tree, R-Tree, Subquery, Prepaed Statement 5.0 Stored Routines, Views, XTranstion 5.1 Event, Row-Based replicatoion, Plugin API 5.5 Support Unicode 5.6 InnoDB Buffer Pool Instance, Memmcached API, GTID 5.7 JSON data type, CJK 檢索, online DDL, JSON Function 8.0 \u0026hellip;  帶您製作新潮、實用且開源的 LINE 電子名片與廣告傳單  Flex Message LIFF  References:  不用寫程式也能做 LINE 數位版名片\n taichunmin/liff-businesscard ","description":"","id":7,"section":"posts","tags":["mysql","acl","chatbot","liff","coscup"],"title":"COSCUP 2021 Day 2","uri":"https://e61983.github.io/2021-08-01-coscup-2021-day-2/"},{"content":"前言 今年的 COSCUP 因應 COVID-19 疫情，所以以線上直播的方式進行。本篇主要是記錄大會第一天有興趣的議程以及關鍵字。\n COSCUP2021\n  主要內容 Introduction to Transactional Memory and Its Implementation GCC Example:\n1 2 3 4 5 6 7 8  #include \u0026lt;stdio.h\u0026gt;int main() { int i = 0; __transaction_atomic { i++; } return 0; }   在編譯的時候要加上 -fgnu-tm\n1  gcc -fgnu-tm   Reference  Slide reborn2266/STM-Toy  Learning go error handling design from open source  “Values can be programmed, and since errors are values, errors can be programmed.” \u0026ndash;Rob Pike\n References:  Don’t just check errors, handle them gracefully Errors are values  A trip about how I contribute to LLVM - Douglas Chen References:  Slide  從 Go 的 runtime 源碼發掘瘋狂的 slice 用法 References  Slide  Select, Manage, and Backport the Long-Term Stable Kernels  Linux CIP\n    References:  共筆 Slide Automotive Linux  Cuju - 虛擬機容錯功能實作 References  Cuju  User authentication in Go Web Server  Rainbow table attack  讓密碼安全性更高的方式  salt (建議32bit) pepper (secret salt)   加鹽的方式\n   password length: 10 ~ 64  OTP (Once Time Password)  Time OTP SMS OTP  Resources:  \u0026ndash;have i been pwned?  Let\u0026rsquo;s Publish a Collaborative e-Book for Linux Kernel References:  共筆 The Linux Kernel Module Programming Guide Original Guide  藉由實作多任務核心來體驗作業系統概念 Raspbootcom:\n raspbootcom\n   Enable UART0 FIFO  References:  Slide DavidSpickett/ARMMultiTasking Raspbootcom  參考連結  TransactionalMemory  Rpi-JTAG\n","description":"","id":8,"section":"posts","tags":["gcc","go","linux","coscup"],"title":"COSCUP 2021 Day 1","uri":"https://e61983.github.io/2021-07-31-coscup-2021-day-1/"},{"content":"前言 一般來說，如果想要調整 Linux Kernel 只要在終端機輸入 make menuconfig 這類的指令就可以了。但如果在不同的開發流程中，就不是這麼單純了。\n本文主要是針對 Yocto 開發流進行記錄，未來有機會的話，會再補充 buildroot 的開發方式。\n主要內容 下圖取自 Yocto 官網。圖中示表了，在 Yocto 環境中開發 Kernel 時的流程\n https://docs.yoctoproject.org/current/kernel-dev/intro.html\n  接下來的內容，筆者已初始化完 Yocto 相關的環境變數。此步驟若不清楚，可參考 這裡\n\n找到 Kernel 來源 Kernel 的配置一般來說，都會放在 conf/machine/ 中，並且會配置 PREFERRED_PROVIDER_virtual/kernel 來指定使用的 kernel。所以我們可以直接以 */conf/machine/*.conf 來進行搜尋。\n1  find . -wholename \u0026#34;*/conf/machine/*.conf\u0026#34;    找尋 machine 配置檔\n  以 qemuarm.conf 為例:\n在這份檔案中我們並沒有看到 PREFERRED_PROVIDER_virtual/kernel 的設定。所以我們要去查看它引入的文件。\n qemuarm.conf\n  在 qemuarm.inc:22 ，我們看到它是配置為 linux-yocto\n qemuarm.inc\n  接下來就是要去找到 linux-yocto 它的配置檔在哪裡了。\n通常它會被放在 recipes-kernel/linux 中，但我們還是可以直接以搜尋的方式找到它。\n1  find . -iname \u0026#34;linux-yocto*\u0026#34;    最後我們可以看 SRC_URL 所指定的位置，即是 Kernel 的來源。\n 呼喚出熟悉的畫面 1  bitbake virtual/kernel -c menuconfig    製作 Configuration Fragment 執行下列指令來產生 configuration fragment。產生的檔案會放置在 ${WORKDIR}/fragment.cfg。\n而 ${WORKDIR} 的位置可參考手冊中註明的位置: ${TMPDIR}/work/${MULTIMACH_TARGET_SYS}/${PN}/${EXTENDPE}${PV}-${PR}。\n1 2 3 4  bitbake virtual/kernel -c diffconfig # 把透過 diffconfig 產生的 fragment.cfg 移過來 \u0008mv tmp/work/qemuarm-poky-linux-gnueabi/linux-yocto/5.4.129+gitAUTOINC+c5e5dc4e13_dfb9647332-r0/fragment.cfg my-local-version.cfg   從內容應該可以看出來，筆者只有修改了 local version 而已。\n1  CONFIG_LOCALVERSION=\u0026#34;-yuan\u0026#34;   接下來我們可以透過 recipetool 幫我們將 my-local-version.cfg 加入我們的 Layer中。\n1  recipetool appendsrcfile meta-first-layer linux-yocto my-local-version.cfg   重新編譯 kernel\n1 2 3 4  bitbake virtual/kernel # 重新編譯 Image bitbake core-image-minimal   使用 qemu 進行驗證\n1  runqemu qemuarm core-image-minimal nographic slirp    修改 LOCALVERSION 之後的結果\n  寫在最後 筆者在驗證修改 LOCALVERSION 是否有修改成功時，返覆的使用下列指令進行確認。\n但時常會沒有修改成功。\n1 2  bitbake linux-yocto -c kernel_configme -f bitbake linux-yocto -c kernel_configcheck -f   若有發現原因，會再進行補充。\n補充說明 如果在執行 bitbake virtual/kernel -c menuconfig 遇到了下列錯誤，可以安裝 screen 或是 tmux 來解決此問題。\nTried the following commands:\ntmux split-window -c \u0026ldquo;{cwd}\u0026rdquo; \u0026ldquo;do_terminal\u0026rdquo;\ntmux new-window -c \u0026ldquo;{cwd}\u0026rdquo; -n \u0026ldquo;linux-imx Configuration\u0026rdquo; \u0026ldquo;do_terminal\u0026rdquo;\nxfce4-terminal -T \u0026ldquo;linux-imx Configuration\u0026rdquo; -e \u0026ldquo;do_terminal\u0026rdquo;\nterminology -T=\u0026ldquo;linux-imx Configuration\u0026rdquo; -e do_terminal mate-terminal \u0026ndash;disable-factory -t \u0026ldquo;linux-imx Configuration\u0026rdquo; -x do_terminal\nkonsole \u0026ndash;separate \u0026ndash;workdir . -p tabtitle=\u0026ldquo;linux-imx Configuration\u0026rdquo; -e do_terminal\ngnome-terminal -t \u0026ldquo;linux-imx Configuration\u0026rdquo; \u0026ndash; do_terminal\nxterm -T \u0026ldquo;linux-imx Configuration\u0026rdquo; -e do_terminal\nrxvt -T \u0026ldquo;linux-imx Configuration\u0026rdquo; -e do_terminal\ntmux new -c \u0026ldquo;{cwd}\u0026rdquo; -d -s devshell -n devshell \u0026ldquo;do_terminal\u0026rdquo;\nscreen -D -m -t \u0026ldquo;linux-imx Configuration\u0026rdquo; -S devshell do_terminal  安裝方式:\n1  sudo apt install -y tmux   小結 在 Yocto 環境中調整 Kernel 其實是有許多方法的，例: 使用自己指定的 Kernel Source、使用我們給定的 defconfig，或是使用 patch 等。\n而我們此次是透過給予 Configuration Fragments 的方式進行。\n未來若有使用到其他方式，會再額外撰寫記錄。\n參考連結  Yocto Project Linux - Kernel Development Manual Yocto How to config image through layer Bitbake append file to reconfigure kernel ","description":"","id":9,"section":"posts","tags":["yocto","linux","kernel"],"title":"在 Yocto 環境中調整 Linux Kernel","uri":"https://e61983.github.io/2021-07-30-yocto-kernel-menuconfig/"},{"content":"前言 突然好奇，要如何在 Hugo 中使用外部資源。本文就先以最簡單的方式，使用 CDN 引入 Bootstrap。\n主要內容 在文中貼上 Bootstrap 官網的 CDN 即可。\n1 2 3  \u0026lt;link href=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; integrity=\u0026#34;sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js\u0026#34; integrity=\u0026#34;sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   接著就可以開始使用了。\n下列以幻燈片作為範例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  \u0026lt;div id=\u0026#34;carouselExampleIndicators\u0026#34; class=\u0026#34;carousel slide\u0026#34; data-bs-ride=\u0026#34;carousel\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;carousel-indicators\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; data-bs-target=\u0026#34;#carouselExampleIndicators\u0026#34; data-bs-slide-to=\u0026#34;0\u0026#34; class=\u0026#34;active\u0026#34; aria-current=\u0026#34;true\u0026#34; aria-label=\u0026#34;Slide 1\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; data-bs-target=\u0026#34;#carouselExampleIndicators\u0026#34; data-bs-slide-to=\u0026#34;1\u0026#34; aria-label=\u0026#34;Slide 2\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; data-bs-target=\u0026#34;#carouselExampleIndicators\u0026#34; data-bs-slide-to=\u0026#34;2\u0026#34; aria-label=\u0026#34;Slide 3\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;carousel-inner\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;carousel-item active\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://picsum.photos/1024/800?random=1\u0026#34; class=\u0026#34;d-block w-100\u0026#34; alt=\u0026#34;demo image 1\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;carousel-item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://picsum.photos/1024/800?random=2\u0026#34; class=\u0026#34;d-block w-100\u0026#34; alt=\u0026#34;demo image 2\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;carousel-item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://picsum.photos/1024/800?random=3\u0026#34; class=\u0026#34;d-block w-100\u0026#34; alt=\u0026#34;demo image 3\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button class=\u0026#34;carousel-control-prev\u0026#34; type=\u0026#34;button\u0026#34; data-bs-target=\u0026#34;#carouselExampleIndicators\u0026#34; data-bs-slide=\u0026#34;prev\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;carousel-control-prev-icon\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;visually-hidden\u0026#34;\u0026gt;Previous\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;carousel-control-next\u0026#34; type=\u0026#34;button\u0026#34; data-bs-target=\u0026#34;#carouselExampleIndicators\u0026#34; data-bs-slide=\u0026#34;next\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;carousel-control-next-icon\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;visually-hidden\u0026#34;\u0026gt;Next\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt;            Previous   Next      小結 使用 CDN 就是如此的樸實無華好上手呀~\n參考連結  Bootstrap 5 Offical  ","description":"","id":10,"section":"posts","tags":["bootstrap","web"],"title":"要如何在Hugo 中使用Bootstrap ?","uri":"https://e61983.github.io/2021-07-28-using-bootstrap-with-hugo/"},{"content":"前言 在準備完開發環境之後，接下來就要開始加上我們的設定、服務或是應用了。\n主要內容 在進行下列操作前，我們需要先初始化 Yocto 環境，如果還不知道要如何進行的同學，可以參考這邊。\n建立我們的 \u0026ldquo;層\u0026rdquo; 建議是將我們的 Layer 放在建置資料夾( first-build )的外面。所以我們將在它的上一層目錄建立我們的 Layer meta-first-layer。\n1 2 3 4  cd .. ls # first-build poky  bitbake-layers create-layer meta-first-layer ls # first-build meta-first-layer poky    加入我們的 \u0026ldquo;層\u0026rdquo; 在建置資料夾( first-build ) 中執行下列指令，它會幫我們更新 conf/bblayer.bb 的內容。\n1 2  cd first-build bitbake-layers add-layer ../meta-first-layer   Recipes-example 我們在建立 meta-first-layer 時，bitbake-layers 會順便幫我們建立 recipes-example。\n我們可以透過下列指令，看到它的輸出結果。\n1  bitbake example   執行結果:\n 執行結果\n  建立我們的 Recipes-Hello Yocto 專案提供了許多便捷的工具，其中 recipetool 與 devtool 便是與 Recipes 較為相關。\n接下來我們將會使用 recipetool 來建立我們的 Recipes。\n建立 recipes-hello 資料夾，並在 files 中放入我們的源始碼。\n1 2  mkdir -p recipes-hello/hello/files cd recipes-hello/hello   main.c:\n1 2 3 4 5 6  #include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { printf(\u0026#34;Hello\\n\u0026#34;); return 0; }   Makefile:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  SRCS := main.c OBJS := $(SRCS:.c=.o) bindir ?= /usr/bin TARGET := hello all: $(TARGET) %.o : %.c $(CC) -c $\u0026lt; -o $@ ${LDFLAGS} $(TARGET) : $(OBJS) $(CC) $^ -o $@ ${LDFLAGS} install: install -d $(DESTDIR)$(bindir) install -m 755 $(TARGET) $(DESTDIR)$(bindir)/   使用 recipetool 建立 recipe\n1  recipetool create -o hello_0.1.bb files   修改產生出的 hello_0.1.bb\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  LICENSE = \u0026#34;CLOSED\u0026#34; LIC_FILES_CHKSUM = \u0026#34;\u0026#34; SRC_URI = \u0026#34; \\ file://main.c \\ file://Makefile \\ \u0026#34; S = \u0026#34;${WORKDIR}\u0026#34; do_configure () { } do_compile () { oe_runmake } do_install () { oe_runmake install \u0026#39;DESTDIR=${D}\u0026#39; }   回到 first-build 進行測試\n1  bitbake hello   可以正常的進行編譯，但在最後出現了問題。\nERROR: hello-0.1-r0 do_package_qa: QA Issue: File /usr/bin/hello in package hello doesn\u0026rsquo;t have GNU_HASH (didn\u0026rsquo;t pass LDFLAGS?) [ldflags]\nERROR: hello-0.1-r0 do_package_qa: QA run found fatal errors. Please consider fixing them.\nERROR: Logfile of failure stored in: /home/yuan/first-build/tmp/work/cortexa7t2hf-neon-vfpv4-poky-linux-gnueabi/hello/0.1-r0/temp/log.do_package_qa.2726283\nERROR: Task (/home/yuan/meta-first-layer/recipes-hello/hello/hello_0.1.bb:do_package_qa) failed with exit code \u0026lsquo;1\u0026rsquo;  參考這篇文章\u0008修改 hello_0.1.bb\n1 2 3 4 5 6 7  do_install () { oe_runmake install \u0026#39;DESTDIR=${D}\u0026#39; } + + INSANE_SKIP_${PN} = \u0026#34;ldflags\u0026#34; + INSANE_SKIP_${PN}-dev = \u0026#34;ldflags\u0026#34;    建立我們的 image 在 recipes-hello 中建立 images 資料夾。\n1 2 3  mkdir -p recipes-hello/images cd recipes-hello/images cp ../../../poky/meta/recipes-core/images/core-image-minimal.bb hello-image.bb   hello-image.bb:\n1 2 3 4 5 6 7 8 9 10  SUMMARY = \u0026#34;A hello image that just for testing our layer\u0026#34; LICENSE = \u0026#34;MIT\u0026#34; IMAGE_INSTALL = \u0026#34;packagegroup-core-boot ${CORE_IMAGE_EXTRA_INSTALL}hello\u0026#34; inherit core-image IMAGE_ROOTFS_SIZE ?= \u0026#34;8192\u0026#34; IMAGE_ROOTFS_EXTRA_SPACE_append = \u0026#34;${@bb.utils.contains(\u0026#34;DISTRO_FEATURES\u0026#34;, \u0026#34;systemd\u0026#34;, \u0026#34; + 4096\u0026#34;, \u0026#34;\u0026#34; ,d)}\u0026#34;   回到 first-build 進行測試\n1 2  bitbake hello-image runqemu hello-image nographic slirp    另一個建立 Recipes-hello 的方法  在工作目錄 ( first-build ) 使用 devtool 加入我們寫好的 hello 至 工作目錄中。\n1  devtool add hello ../hello   這個動作會幫我們在 conf/bblayer.bb 中加入 workspace 層，並建立 workspace/recipes/hello 資料夾。\n使用下列指令編譯 hello\n1 2  devtool build hello ls   可以發現它確實多了 Workspace Layer\n 使用 devtool 建立臨時測試用的 image，並使用 qemu 進行驗證。\n1 2  devtool build-image core-image-minimal runqemu core-image-minimal nographic slirp    在測試沒有問題之後，再使用 devtool 將 hello 加入我們的 Layer\n1  devtool finish hello ../meta-first-layer   小結 我們已經建立了自己的 Layer、Recipe 以及 Image。 接下來我們就可以試著建立屬於我們的 Distribution 和 Machine 了。\n參考連結  Building your own recipes from first principles How to fix : ERROR: do_package_qa: QA Issue: No GNU_HASH in the elf binary Devtool Reference Yocto Manual ","description":"","id":11,"section":"posts","tags":["yocto"],"title":"Yocto First Layer","uri":"https://e61983.github.io/2021-07-28-yocto-first-layer/"},{"content":"前言 先前有接觸過 buildroot 這類的 Linux Distribution 工具，但一直沒有好好的整理起來。\n最近剛好有機會接觸 Yocto，打算在摸索的過程中一並記錄起來。\n主要內容 Yocto 專案 有關於 Yocto 專案的歴史就不多做介紹了，有興趣的同學可以到它的官網看看。\n Yocto 官網畫面\n  基本觀念  Yocto 開發流程\n  Machine 相關的配置會放在 conf/machine/ 中。它用來描述與硬體有關的配置。通常包含: Kernel、Devices Tree、Bootloader。\nDistrobution 相關的配置會放在 conf/distro/ 中。它作為整個配置中最底層的部份。接下來的 Layer 都會以此為基礎往上疊加。通常它也訂定了此系統的 ABI 。\nImage 相關的配置會放在 recipes-*/images/ 中。它就是 rootfs。\nLayer 是由 Recipe 所組成，根據不同用途可以定義出BSP Layer, General Layer。\n一般來說我們會以  meta- 開頭作為 Layer 的命名。\nRecipe 是由一系列建構 Package 的指令所組成。描述了 Package 該如何取得源始碼、如何進行配置、如何進行編譯以及安裝的步驟。\nPackage 在 Yocto 中 Package 是代表 Recipe 的執行結果。\n 建立 Yocto 環境 下載 Poky。\n 等一下\u0026hellip; 怎麼突然就冒一個 poky 出來\n這個就先請同學自行去 Yocto 的官網看了\n 1 2  mkdir yocto \u0026amp;\u0026amp; cd yocto git clone git://git.yoctoproject.org/poky.git   輸入下列指令初始化環境，它會幫我們建立 first-build 資料夾。並設置好相關的環境變數。\n1  source poky/oe-init-build-env first-build   開始第一個專案 輸入下列指令，就會開始進行編譯了。\n1  \u0008bitbake core-image-miminal   依照網路環境、編譯主機的不同，執行的時間會有所不同。但第一次都要蠻久的就是了。  在編譯完成之後，使用 qemu 來看看成果。\n1  runqemu qemuarm core-image-miminal nographic slirp   使用 root 登入\n 登入畫面\n  小結 本文記錄了 Yocto 開發時會需要知道的基楚資訊，未來在開發時，有發現不足的部份會再持續的補充。\n參考連結  Yocto Official Bootlin - Introduction to Yocto project ","description":"","id":12,"section":"posts","tags":["yocto","linux"],"title":"Yocto 基礎介紹","uri":"https://e61983.github.io/2021-07-27-yocto-introduction/"},{"content":"前言 手邊有一片很久沒有動過的 Raspberry Pi 3 B+。剛好最近工作上需要在 imx8 進行開發。藉此順便先練練手。\n主要內容 準備 Yocto 環境  建立我們要開發的資料夾 my-rpi，接下來我們都會在這個資料夾中進行操作。 下載 poky 。  1 2  mkdir my-rpi \u0026amp;\u0026amp; cd my-rpi git clone -b hardknott git://git.yoctoproject.org/poky.git   準備 meta-raspberrypi 層\n1  git clone -b hardknott git://git.yoctoproject.org/meta-raspberrypi   初始化開發環境\n1  source poky/oe-init-build-env build-rpi   加入 meta-raspibary 層\n1  bitbake-layers add-layer ../meta-raspberrypi   修改配置 1 2 3 4 5 6  sed -i \u0026#39;s/^MACHINE.*/MACHINE ?= \u0026#34;raspberrypi3\u0026#34;/g\u0026#39; conf/local.conf sed -i \u0026#39;/^#DL_DIR ?= \u0026#34;${TOPDIR}\\/downloads\u0026#34;/ a DL_DIR ?= \\\u0026#34;${HOME}/yocto/downloads\u0026#34;\u0026#39; conf/local.conf sed -i \u0026#39;s/^PACKAGE_CLASSES.*/PACKAGE_CLASSES ?= \u0026#34;package_ipk\u0026#34;/g\u0026#39; conf/local.conf echo \u0026#39;RPI_USE_U_BOOT = \u0026#34;1\u0026#34;\u0026#39; \u0026gt;\u0026gt; conf/local.conf echo \u0026#39;ENABLE_UART = \u0026#34;1\u0026#34;\u0026#39; \u0026gt;\u0026gt; conf/local.conf   開始編譯 1  bitbake core-image-minimal   寫入 SD Card 1 2  bzip -Dk core-image-minimal-raspberrypi3.wic.bz2 sudo dd if=core-image-minimal-raspberrypi3.wic of=${SD_CARD} bs=40960   小結 編譯出來的系統已可以開始，並在UART 終端機看到開始時的輸出，以及可以使用root 進入系統。\n參考連結  Yocto official meta-raspberrypi Building Raspberry Pi Systems with Yocto ","description":"","id":13,"section":"posts","tags":["linux","yocto"],"title":"使用 Yocto 打造你的 Raspberry Pi 系統","uri":"https://e61983.github.io/2021-07-26-building-raspberry-pi-systems-with-yocto/"},{"content":"前言 以前有使用過 hexo 建立Blog，但一直沒有好好的經營。最近又有想要開始寫 Blog 的念頭。\n希望這一次，可以持續撰寫下去。\n主要內容 由於筆者是使用 MacBook 作為日常使用的工具，所以本文將以 Mac 環境進行筆記。\n安裝 Hugo 1  brew install hugo   建立網站 1  hugo new ${SITE_NAME}   撰寫文章 1 2  cd ${SITE_NAME} hugo new posts/my-first-post.md   設定佈景主題 1 2  git submodule add https://github.com/upagge/uBlogger.git themes/uBlogger echo \u0026#39;theme = \u0026#34;uBlogger\u0026#34;\u0026#39; \u0026gt;\u0026gt; config.toml   修改樣式 建立相關資料夾\n1  mkdir -p assets/css/   加入自訂樣式\n1 2 3 4  code[class*=\u0026#34;language-\u0026#34;] { color: white; text-shadow: none; }   小結 這次只有進行簡易的設定，還有許多功能還未探索。目前打算先用一陣子，再看看還有什麼有趣的東西。\n參考連結  uBlogger offical website 第 12 屆 iT 邦幫忙鐵人賽 - Hugo 貼身打造個人部落格 系列 ","description":"","id":14,"section":"posts","tags":["go","web","markdown"],"title":"打造自己的Blog","uri":"https://e61983.github.io/2021-07-26-first-hugo-website/"},{"content":"前言 使 GNU LD 輸出總共使用的記憶體大小與程式大小。\n主要內容 Makefile:\nLDFLAGS += -Wl,--print-memory-usage 參考連結  GNU LD - command options ","description":"","id":15,"section":"posts","tags":["linker"],"title":"GNU LD print memory usage","uri":"https://e61983.github.io/2018-02-06-ld-print-memory-usage/"},{"content":"前言 Generic 在C11上出現，我們可以透過實作出物件導向中的多型。要注意的是 Generic 是在編譯時期運作的。\n主要內容 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;stdio.h\u0026gt;void funci(int x) { printf(\u0026#34;func value = %d\\n\u0026#34;, x); } void funcc(char c) { printf(\u0026#34;func char = %c\\n\u0026#34;, c); } void funcdef(double v) { printf(\u0026#34;Def func\u0026#39;s value = %lf\\n\u0026#34;, v); } #define func(X) \\ _Generic((X), \\ int: funci, char: funcc, default: funcdef \\ )(X) int main() { func(1); func(\u0026#39;a\u0026#39;); func(1.3); return 0; }   在多個參數的使用上比較繁瑣，需要自行作每個參數的組合。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #define format2(x,y) _Generic((x), \\ char: _Generic((y), \\ char:\u0026#34;%c - %c\\n\u0026#34;, \\ char*:\u0026#34;%c - %s\\n\u0026#34;, \\ int:\u0026#34;%c - %d\\n\u0026#34;, \\ default:\u0026#34;error\\n\u0026#34; \\ ), \\ char*: _Generic((y), \\ char:\u0026#34;%s - %c\\n\u0026#34;, \\ char*:\u0026#34;%s - %s\\n\u0026#34;, \\ int:\u0026#34;%s - %d\\n\u0026#34;, \\ default:\u0026#34;error\\n\u0026#34; \\ ), \\ int: _Generic((y), \\ char:\u0026#34;%d - %c\\n\u0026#34;, \\ char*:\u0026#34;%d - %s\\n\u0026#34;, \\ int:\u0026#34;%d - %d\\n\u0026#34;, \\ default:\u0026#34;error\\n\u0026#34; \\ ), \\ default:\u0026#34;error\\n\u0026#34; \\ )  #define print2(x, y) printf(format2(x,y),x,y) int main(int argc, char **argv) { printf(\u0026#34;test 2 parameters\\n\u0026#34;); print2(3, \u0026#39;c\u0026#39;); return 0; }   ","description":"","id":16,"section":"posts","tags":["c11"],"title":"C11 Generic Selections","uri":"https://e61983.github.io/2017-10-18-c11-generic-selections/"}]