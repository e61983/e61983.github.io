[{"content":"前言 會有這一篇的誕生是因為原本在寫 gRPC 的筆記時發現篇幅太長，想還是開寫好了。於是乎這一篇就出現了。\n我們會先對 Protocol Buffer 的語法進行瞭解，接著撰寫、並轉譯一個範例，最後實際的跑一個範程式。\n主要內容 Protocol Buffers（簡稱：ProtoBuf）是一種開源跨平台的序列化資料結構的協定。其對於儲存資料或在網路上進行通訊的程式是很有用的。這個方法包含一個介面描述語言，描述一些資料結構，並提供程式工具根據這些描述產生程式碼，這些代碼將用來生成或解析代表這些資料結構的位元組流。\n資料來源: https://zh.wikipedia.org/zh-tw/Protocol_Buffers\n資料型態 int / int32 / int64\nuint / uint32 / uint64\nbool\nfloat\ndouble\nbytes\nstring\nenum ( Enumeration )\nfirst defined enum value, which must be 0.\nmap\nany\ntimestamp / duration\n可以參考這裡\n資料欄修飾字 oneof required\n表示該資料欄是必要的。 optional\n指該資料欄是可選的 (0筆或1筆)。 repeated\n指該資料欄是可以有多筆的。 reserved 範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 syntax = \u0026#34;proto3\u0026#34;; option go_package = \u0026#34;foo.example.idv/protobuf/example\u0026#34;; import \u0026#34;google/protobuf/timestamp.proto\u0026#34;; message Employee { string name = 1; google.protobuf.Timestamp Birthday = 2; }; message Company { string name = 1; repeated Employee employees = 2; }; 安裝 Protocol Buffer 編譯器 1 2 brew install protobuf go install google.golang.org/protobuf/cmd/protoc-gen-go@latest 產生相應的 Go 程式碼 1 2 3 protoc --go_out=. \\ --go_opt=paths=source_relative \\ protobuf/example/foo.proto 如果出現\nprotoc-gen-go: program not found or is not executable\n這個錯誤，請同學先確認一下 ~/go/bin 是否有在你的 $PATH 中。\n如果沒有就把它加進去吧！\n你可以\nexport PATH=$HOME/go/bin:$PATH\n結果 1 2 ls foo.pb.go foo.proto 實際用看看 我們來撰寫一支程式，實際的使用剛剛產生的程式碼。\n它會建立一個使用 protobuf 結構的序列化檔案 foo。\n並且再將它讀回並顯示出來。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 com := \u0026amp;example.Company{ Name: \u0026#34;FooBarBar\u0026#34;, Employees: []*example.Employee{ {Name:\u0026#34;Alice\u0026#34;}, {Name:\u0026#34;Bonny\u0026#34;}, {Name:\u0026#34;Candy\u0026#34;}, }, } out, err := proto.Marshal(com) if err != nil { log.Fatalln(\u0026#34;Failed to encode address book:\u0026#34;, err) } if err := ioutil.WriteFile(\u0026#34;foo\u0026#34;, out, 0644); err != nil { log.Fatalln(\u0026#34;Failed to write company:\u0026#34;, err) } in, err := ioutil.ReadFile(\u0026#34;foo\u0026#34;) if err != nil { log.Fatalln(\u0026#34;Error reading file:\u0026#34;, err) } com2 := \u0026amp;example.Company {} if err := proto.Unmarshal(in, com2); err != nil { log.Fatalln(\u0026#34;Failed to parse company:\u0026#34;, err) } 實際來一遍 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 mkdir -p test/protobuf/example cd test cat \u0026lt;\u0026lt; EOF \u0026gt; protobuf/example/foo.proto syntax = \u0026#34;proto3\u0026#34;; option go_package = \u0026#34;foo.example.idv/protobuf/example\u0026#34;; import \u0026#34;google/protobuf/timestamp.proto\u0026#34;; message Employee { string name = 1; google.protobuf.Timestamp Birthday = 2; }; message Company { string name = 1; repeated Employee employees = 2; }; EOF cat \u0026lt;\u0026lt; EOF \u0026gt; main.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; \u0026#34;foo.example.idv/protobuf/example\u0026#34; \u0026#34;google.golang.org/protobuf/proto\u0026#34; ) func main(){ com := \u0026amp;example.Company{ Name: \u0026#34;FooBarBar\u0026#34;, Employees: []*example.Employee{ {Name:\u0026#34;Alice\u0026#34;}, {Name:\u0026#34;Bonny\u0026#34;}, {Name:\u0026#34;Candy\u0026#34;}, }, } fmt.Println(\u0026#34;original\u0026#34;) fmt.Println(com) fmt.Println(\u0026#34;==============================\u0026#34;) out, err := proto.Marshal(com) if err != nil { log.Fatalln(\u0026#34;Failed to encode address book:\u0026#34;, err) } if err := ioutil.WriteFile(\u0026#34;foo\u0026#34;, out, 0644); err != nil { log.Fatalln(\u0026#34;Failed to write company:\u0026#34;, err) } in, err := ioutil.ReadFile(\u0026#34;foo\u0026#34;) if err != nil { log.Fatalln(\u0026#34;Error reading file:\u0026#34;, err) } com2 := \u0026amp;example.Company {} if err := proto.Unmarshal(in, com2); err != nil { log.Fatalln(\u0026#34;Failed to parse company:\u0026#34;, err) } fmt.Println(\u0026#34;read from file\u0026#34;) fmt.Println(com2) } EOF go mod init foo.example.idv go get google.golang.org/protobuf/proto protoc --go_out=. --go_opt=paths=source_relative protobuf/example/foo.proto go mod tidy clear go run main.go 結果 1 2 3 4 5 original name:\u0026#34;FooBarBar\u0026#34; employees:{name:\u0026#34;Alice\u0026#34;} employees:{name:\u0026#34;Bonny\u0026#34;} employees:{name:\u0026#34;Candy\u0026#34;} ============================== read from file name:\u0026#34;FooBarBar\u0026#34; employees:{name:\u0026#34;Alice\u0026#34;} employees:{name:\u0026#34;Bonny\u0026#34;} employees:{name:\u0026#34;Candy\u0026#34;} 小結 本文的介紹十分的簡約，如果想要瞭解更多可以參考官方網站的說明。\n如果對 protobuf 實際的資料結構有興趣不仿可以對著官方文件研究一下 實際來一遍 所產生的 foo 檔案。\n參考連結 Protocol Buffer Basics: Go Protocol Buffer - Scalar Value Types Go Generated Code ","description":"","id":0,"section":"posts","tags":["go","protobuf"],"title":"在 Go 中與 Protobuf 共舞 ？！","uri":"https://e61983.github.io/2022-08-09-go-and-protobuf/"},{"content":"前言 前一陣子每天下班後花 2 個小時讀書，終於通過了周三的考試。本文主要會簡述它是什麼以及要如何準備它！\n主要內容 筆者報名的是恆逸連續 5 天，每天 8 小時遠距教學。\n一開始很天真的想在上完課後直接報名隔週的考試，看看能不能在 10 天內取得它。 (( 年輕人終究是年輕人 ~\nCertificated Ethical Hacker (CEH) Certificated Ethical Hacker ( 道德駭客認證 )，主要是在於教導、介紹一些駭客常用的工具和方法。所謂知己知彼 百戰不殆，藉由瞭解攻擊方式以及原理進而進行系統防護。\n課程範圍 Introduction to Ethical Hacking (介紹何謂道德入侵) Footprinting and Reconnaissance (蒐集蛛絲馬跡與網路勘查) Scanning Networks (網路服務與弱點掃描) Enumeration (列舉系統資訊) Vulnerability Analysis (弱點分析) System Hacking (入侵電腦系統) Malware Threats (惡意程式威脅) Sniffers (網路監聽與攻擊) Social Engineering (社交工程) Denial-of-Service (阻斷服務攻擊與傀儡網路) Session Hijacking (連線劫持) Evading IDS, Firewalls and Honeypots (規避入侵偵測/防火牆與誘捕系統) Hacking Webservers (入侵網站) Hacking Web Application (入侵網站程式) SQL Injection (資料隱碼攻擊) Hacking Wireless Network (入侵無線網路) Hacking Mobile Platforms (入侵行動平台) IoT and OT Hacking(入侵物聯網與工控) Cloud Computing (雲端運算) Cryptography (密碼學) 考試題目的類型 150 道選擇題上機考。 題目大多是考:\n攻擊類型 / 原理 / 方式\n例:\nWhile performing online banking using a Web browser, a user receives an email that contains a link to an interesting Web site. When the user clicks on the link, another Web browser session starts and displays a video of cats playing a piano. The next business day, the user receives what looks like an email from his bank, indicating that his bank account has been accessed from a foreign country. The email asks the user to call his bank and verify the authorization of a funds transfer that took place. What Web browser-based security vulnerability was exploited to compromise the user?\nA. Clickjacking\nB. Cross-Site Request Forgery\nC. Cross-Site Scripting\nD. Web form input validation\n防範方式 / 方法\n例:\nSome clients of TPNQM SA were redirected to a malicious site when they tried to access the TPNQM main site. Bob, a system administrator at TPNQM SA, found that they were victims of DNS Cache Poisoning.\nWhat should Bob recommend to deal with such a threat?\nA. The use of security agents in clients\u0026rsquo; computers\nB. The use of double-factor authentication\nC. Client awareness\nD. The use of DNSSEC\n工具軟體與使用方式\n例:\nIf you want to only scan fewer ports than the default scan using Nmap tool, which option would you use?\nA. -n\nB. -F\nC. -O\nD. -sT\n通訊協定與其它背科\n例:\nIdentify the UDP port that Network Time Protocol (NTP) uses as its primary means of communication?\nA. 131\nB. 3389\nC. 123\nD. 160\n報名考式 筆者在上完課之後，立馬詢問了要如何報名考試。才知道考試需要提前 5 天進行。所以報名了後面的梯次。\n考試報名連結\nExam 跟 ASPEN 的信箱不一樣 ？！ 上課的時候會在 ASPEN 上建立帳號來取得電子教材。\n考試的時候會是在 EC Council - Exam Center 進行考試。\n當考試完通過之後要取得電子證書時，這兩個平台是認注冊時的電子信箱的。\n如果這兩個平台使用的 是不同信箱，在發證時會自動用你 Exam Center 的信箱幫你在 ASPEN 建立帳號。\n後續就可以用忘記密碼的流程來設定密碼。\n上課時的帳號\n考過後自動產生的帳號\n秀 Time 不免俗的還是要來秀一下證書\nCEH 證書\n在官方提供的證書驗證頁面來輸入姓名與證號來驗證它否是為有效的證書。\n小結 筆者是參加 06/06 為期 5 天的課程，並每天下班後利用 0.5 ~ 2 小時進行準備。\n一開始主要是以複習電子教材、在線上 Lab 環境中進行教材內的實驗。\n到了後期改使用網路上可用的考古題資源，進行考題準備。\n在 07/09 參加了第一次考試，結果沒有通過測驗。\n有了前一次考試的經驗，大致上有找到準備的方向。\n於是在 08/03 參加了第二次考試，取得了這張證照。\n如果未來有同學也想取得這張證照的話，或許在上完課之後可以專心的刷考古題。\n幫助蠻大的。\n參考連結 官方網站 EC Council - Exam Center ECCouncil 312-50v11 Exam ","description":"","id":1,"section":"posts","tags":["ceh","hacker"],"title":"Certificated Ethical Hacker (CEH) 考試小記","uri":"https://e61983.github.io/2022-08-06-ceh-exam-v11/"},{"content":"前言 最近發現家中的 NAS 速度 \u0026ldquo;好像\u0026rdquo; 沒有達到筆者的預期。所以想來實際測看看可以目前的網路環境可以跑到什麼程度。於似乎這一篇就誕生了。\n主要內容 測試的 NAS 型號為: DS214。\n在 Synology NAS 運行 iperf 服務 安裝 iperf3 1 2 3 4 ssh synology-nas sudo -i synogear install synogear list # 檢視 iperf 執行 1 iperf3 -s 輸出 1 2 3 4 (synogear) root@synology-nas:~# iperf3 -s ----------------------------------------------------------- Server listening on 5201 ----------------------------------------------------------- 在目標機器上執行 iperf 用戶端程式 由於筆者要測的機器是 Macbook ，所以下面就是以它為主！\n安裝 1 brew install iperf3 執行 1 iperf3 -c synology-nas 輸出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 iperf3 -c synology-nas 1 ↵ Connecting to host synology-nas, port 5201 [ 7] local 192.168.0.100 port 59650 connected to 192.168.0.101 port 5201 [ ID] Interval Transfer Bitrate [ 7] 0.00-1.00 sec 19.9 MBytes 167 Mbits/sec [ 7] 1.00-2.00 sec 29.1 MBytes 244 Mbits/sec [ 7] 2.00-3.00 sec 29.1 MBytes 244 Mbits/sec [ 7] 3.00-4.00 sec 28.3 MBytes 238 Mbits/sec [ 7] 4.00-5.00 sec 19.9 MBytes 167 Mbits/sec [ 7] 5.00-6.00 sec 22.0 MBytes 184 Mbits/sec [ 7] 6.00-7.00 sec 22.6 MBytes 189 Mbits/sec [ 7] 7.00-8.00 sec 20.0 MBytes 168 Mbits/sec [ 7] 8.00-9.00 sec 20.3 MBytes 171 Mbits/sec [ 7] 9.00-10.00 sec 20.8 MBytes 174 Mbits/sec - - - - - - - - - - - - - - - - - - - - - - - - - [ ID] Interval Transfer Bitrate [ 7] 0.00-10.00 sec 232 MBytes 195 Mbits/sec sender [ 7] 0.00-10.00 sec 232 MBytes 195 Mbits/sec receiver iperf Done. 小結 好的。果然沒有達到預期的速度。\nつづく\n參考連結 Synology synogear 工具箱 ","description":"","id":2,"section":"posts","tags":["synology","nas","iperf"],"title":"在 Synology NAS 開啟 iperf 伺服器","uri":"https://e61983.github.io/2022-08-02-use-iperf-on-synology-nas/"},{"content":"前言 最近終於有時間整裡筆者家中的 NAS 。先前筆者已經架設好了 Gitea，但一直沒有時間把整個開發環境串起來。這篇文章記錄了如何在 go 中使用自架的 Git Repository。\n主要內容 由於筆者所架設的 Gitea 並不是使用 http/https 埠作為網站所使用的埠。所以當執行 go get 時會無法正常的動作。\n所以本文主要想解決的問題有:\n讓 go 可以使用私有的 Git repository 讓 go 可以從非標準的 http/https 埠下載程式碼。 go get 的運作原理 從 [1] 我們可以知道，go get 在下載程式碼時有三種匹配方式，來決定要使用什麼工具來抓取程式碼。\nprefix matching\n直接比對網址使用定好的協定。\nregular expression matching\n比對網址結尾是否為已知的版控協定。\ndynamic matching\n會送出 http/https 請求，並在返回的 http 中的 meta 標簽選定要用的協定。\n除此之外\ngo get 它預設會使用 GOPROXY 來加快下載的速度。\n我們可以透過設定 GOPRIVATE 來避免 go 使用 proxy 進行程式碼下載。\n1 go env -w GOPRIVATE=\u0026#34;foo.example.idv/*\u0026#34; 策略 在已經知道 go get 下載程式碼的方式後，筆者決定從 regular expression matching 下手。\n讓模組名稱以 .git 作為結尾。\ngit 使用 insteadOf 改寫 url 我們可以對 git 進行設定，使其改寫我們指定的 url。\n1 git config --global url.\u0026#34;http://foo.example.idv:8080\u0026#34;.insteadof \u0026#34;http://foo.example.idv\u0026#34; 或是\n1 git config --global url.\u0026#34;ssh://foo.example.idv:\u0026#34;.insteadof \u0026#34;http://foo.example.idv\u0026#34; 策略 go get 底層也是使用 git 進行來對使用 git 進行版控的程式碼進行懆作。\n所以我們就可以對它動點手腳，使它可以抓取非 http/https 埠的程式。\n指定 ssh 所使用的 key 其實到了上一步我們就已經可以從我們的git repository 抓取程式碼了。\n但筆者比較習慣使用 ssh 的協定，所以才會有這一個章節。\ngit 使用 ssh 協定抓取程式碼，走的是 ssh 協定 (( 廢話 ~~\n所以我們可以使用 ssh config 來進行設定。\n~/.ssh/config:\n1 2 3 4 5 6 Host foo.example.idv Hostname foo.example.idv Port 22 User git IdentitiesOnly yes IdentityFile ~/.ssh/id_rsa.pub 滲在一起做撒尿牛丸 1 go env -w GOPRIVATE=\u0026#34;foo.example.idv/*\u0026#34; ~/.gitconfig\n1 2 [url \u0026#34;ssh://foo.example.idv:\u0026#34;] insteadOf = https://foo.example.idv ~/.ssh/config\n1 2 3 4 5 6 Host foo.example.idv Hostname foo.example.idv #192.168.1.100 Port 2234 User git IdentitiesOnly yes IdentityFile ~/.ssh/id_rsa.pub 開始新專案時\n1 go mod init foo.example.idv/foo.git 小結 雖然在專案中都要以 .git 作為結尾，但除了這點目前還沒有遇到其它不方便的地方。\n如果未來有找到更好的方法，也會跟大家說的！\n參考連結 私有化仓库的 GO 模块使用实践 Go Module：私有不合规库怎么解决引用问题 Go Modules 處理私有 GIT Repository 流程 ","description":"","id":3,"section":"posts","tags":["go","git","ssh"],"title":"Go 語言使用私有 Git Repository","uri":"https://e61983.github.io/2022-07-30-go-module-using-private-repository/"},{"content":"前言 最近寫 Go 時想嘗試使用動態連結函式庫。於是乎這一篇就誔生了。\n本文會試著使用 Go 編出一個動態連結函式庫，並使用 C 語言程式以及 Go 語言程式呼叫它。\n主要內容 動態連結函式庫 官方文件中有提到，可以被呼叫的函式要使用 export 註解 來提示 cgo。\n-buildmode=c-shared\nBuild the listed main package, plus all packages it imports,\ninto a C shared library. The only callable symbols will\nbe those functions exported using a cgo //export comment.\nRequires exactly one main package to be listed.\n程式碼 (hello.go) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import \u0026#34;C\u0026#34; //export hello func hello() { println(\u0026#34;Hello, world! Library\u0026#34;) } /* We need the main function to make possible cgo compiler to compile the package as c shared library. */ func main() {} 編譯 1 go build -buildmode=c-shared -o libhello.so hello.go 結果 1 libhello.h libhello.so C 語言程式 main.c\n1 2 3 4 5 6 7 8 #import \u0026lt;stdio.h\u0026gt; #import \u0026#34;libhello.h\u0026#34; int main(int argc, char *argv[]) { printf(\u0026#34;Hello world C !\\n\u0026#34;); hello(); return 0; } 編譯 1 gcc -o main_c.out -L. -I. -lhello main.c 結果 1 2 3 ./main_c.out Hello world C ! Hello, world! Library Go 語言程式 v1 main.go\n1 2 3 4 5 6 7 8 9 10 11 package main // #cgo LDFLAGS: -lhello -L. // #include \u0026lt;libhello.h\u0026gt; import \u0026#34;C\u0026#34; import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello world Go!\u0026#34;) C.hello() } 編譯 1 go build -o main_go.out main.go Go 語言程式 v2 main_dl.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package main // #cgo LDFLAGS: -ldl // #include \u0026lt;dlfcn.h\u0026gt; import \u0026#34;C\u0026#34; import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) // load dynamic library func load(path string) (unsafe.Pointer, error) { handle, err := C.dlopen(C.CString(path), C.RTLD_LAZY) if err != nil { return nil, err } return handle, nil } // get symbol func findSym(lib unsafe.Pointer, sym string) (unsafe.Pointer, error) { pc := C.dlsym(lib, C.CString(sym)) if pc == nil { return nil, fmt.Errorf(\u0026#34;find symbol %s failed\u0026#34;, sym) } return pc, nil } // unload dynamic library func unload(lib unsafe.Pointer) error { if C.dlclose(lib) != 0 { return fmt.Errorf(\u0026#34;unload library failed\u0026#34;) } return nil } // entry point function func main() { println(\u0026#34;Hello World\u0026#34;) lib, err := load(\u0026#34;./libhello.so\u0026#34;) if err != nil { panic(err) } defer unload(lib) addr, err := findSym(lib, \u0026#34;hello\u0026#34;) if err != nil { panic(err) } var hello func() p := \u0026amp;addr hello = *(*func())(unsafe.Pointer(\u0026amp;p)) hello() } 編譯 1 go build -o main_go_dl.out main_dl.go 小結 原本也想試試 Node.js 的使用動態連結函式庫的部份。但是相關的函式庫 ffi 一直無法正常的安裝，最後就沒有往下測了。\n參考連結 go build mode Golang生成共享庫(shared library)以及Golang生成C可調用的動態庫.so和靜態庫.a vladimirvivien/go-cshared-examples ","description":"","id":4,"section":"posts","tags":["go","c","library"],"title":"Go語言、動態連結函式庫與它們的產地","uri":"https://e61983.github.io/2022-07-21-golang-with-shared-library/"},{"content":"前言 最近剛好有機會要寫有圖形化介面的程式。想來想去感覺可以寫寫看 Electron！於是乎本篇就這樣誕生了。\n主要內容 建立 Vue 專案 1 2 3 4 yarn create vite test-001 --template vue cd test-001 yarn yarn dev 加入路徑別名 把專案中的 src 加上別名 @。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 mv vite.config.js vite.config.cjs.bk cat \u0026lt;\u0026lt; EOF \u0026gt; vite.config.cjs import { defineConfig } from \u0026#39;vite\u0026#39; import Vue from \u0026#39;@vitejs/plugin-vue\u0026#39; import path from \u0026#39;path\u0026#39; // https://vitejs.dev/config/ export default defineConfig({ plugins: [ Vue(), ], resolve: { alias: { \u0026#39;@\u0026#39;: path.resolve(__dirname, \u0026#39;./src\u0026#39;), }, }, }) EOF 安裝及設定 Tailwindcss 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 yarn add -D tailwindcss postcss autoprefixer cat \u0026lt;\u0026lt; EOF \u0026gt; postcss.config.cjs module.exports = { plugins: { tailwindcss: {}, autoprefixer: {}, } } EOF cat \u0026lt;\u0026lt; EOF \u0026gt; tailwind.config.cjs module.exports = { content: [ \u0026#34;./index.html\u0026#34;, \u0026#34;./src/**/*.{vue,js,ts,jsx,tsx}\u0026#34;, ], theme: { extend: {}, }, plugins: [], } EOF mkdir -p src/styles cat \u0026lt;\u0026lt; EOF \u0026gt; src/styles/base.css @layer base { html, body, #app { @apply h-full w-full; } body, #app { @apply bg-[#333333]; @apply font-light; } } EOF cat \u0026lt;\u0026lt; EOF \u0026gt; src/styles/components.css @layer components { * { @apply outline outline-1 outline-red-500; } } EOF cat \u0026lt;\u0026lt;EOF \u0026gt; src/styles/index.css @import \u0026#34;tailwindcss/base\u0026#34;; @import \u0026#34;base.css\u0026#34;; @import \u0026#34;tailwindcss/components\u0026#34;; @import \u0026#34;components.css\u0026#34;; @import \u0026#34;tailwindcss/utilities\u0026#34;; EOF sed -i \u0026#34;3iimport \u0026#39;@/styles/index.css\u0026#39;\u0026#34; src/main.js sed -i \u0026#39;/\u0026lt;\\/template\u0026gt;/i \\ \\ \\\u0026lt;h1\\ class=\\\u0026#34;text-red-200\\\u0026#34;\\\u0026gt;Hello\\ world\\\u0026lt;\\/h1\\\u0026gt;\u0026#39; src/App.vue 加入 Unplugin Icons 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 yarn add --dev unplugin-vue-components unplugin-icons @iconify/json mkdir -p src/components sed -i \u0026#34;4iimport Components from \u0026#39;unplugin-vue-components/vite\u0026#39;\u0026#34; vite.config.cjs sed -i \u0026#34;4iimport IconsResolver from \u0026#39;unplugin-icons/resolver\u0026#39;\u0026#34; vite.config.cjs sed -i \u0026#34;4iimport Icons from \u0026#39;unplugin-icons/vite\u0026#39;\u0026#34; vite.config.cjs sed -i \u0026#39;/plugins:/a \\ \\ \\ \\ \\ Components({\\ dirs: [\u0026#34;src/components\u0026#34;],\\ resolvers: [\\ IconsResolver({\\ prefix: false,\\ enabledCollections: [\u0026#34;mdi\u0026#34;],\\ })\\ ],\\ }),\\ Icons(),\u0026#39; vite.config.cjs sed -i \u0026#39;/\u0026lt;\\/template\u0026gt;/i \\ \\ \\\u0026lt;mdi-account-heart\\ \\/\\\u0026gt;\u0026#39; src/App.vue 加入 Vue Router 和 vite-plugin-pages 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 yarn add vue-router@4 yarn add --dev vite-plugin-pages mkdir -p src/router cat \u0026lt;\u0026lt; EOF \u0026gt; src/router/index.js import { createRouter, createWebHistory, createWebHashHistory } from \u0026#34;vue-router\u0026#34;; import routes from \u0026#34;~pages\u0026#34;; const router = createRouter({ // refer to: https://nklayman.github.io/vue-cli-plugin-electron-builder/guide/commonIssues.html history: import.meta.env.PROD ? createWebHashHistory() : createWebHistory(import.meta.env.BASE_URL), routes, }); export default router; EOF mkdir -p src/pages sed -i \u0026#34;4iimport Pages from \u0026#39;vite-plugin-pages\u0026#39;\u0026#34; vite.config.cjs sed -i \u0026#39;/plugins:/a \\ \\ \\ \\ \\ Pages({\\ dirs: [\\ { dir: \u0026#34;src/pages\u0026#34;, baseRoute: \u0026#34;\u0026#34; },\\ ],\\ }),\u0026#39; vite.config.cjs sed -i \u0026#34;3iimport Router from \u0026#39;./router\u0026#39;\u0026#34; src/main.js sed -i \u0026#39;s/createApp(App)/createApp(App).use(Router)/\u0026#39; src/main.js cat \u0026lt;\u0026lt; EOF \u0026gt; src/App.vue \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;w-full h-full p-1\u0026#34;\u0026gt; \u0026lt;RouterView\u0026gt;\u0026lt;/RouterView\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; EOF cat \u0026lt;\u0026lt; EOF \u0026gt; src/pages/index.vue \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;flex w-full h-full rounded overflow-hidden\u0026#34;\u0026gt; \u0026lt;div :class=\u0026#34;[ \u0026#39;transition-all duration-500 ease-out\u0026#39;, \u0026#39;h-full w-0 lg:block lg:w-2/12 flex-shrink-0\u0026#39;, \u0026#39;max-w-xs\u0026#39; ]\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;flex h-full w-full\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;@/assets/vue.svg\u0026#34; class=\u0026#34;w-1/4\u0026#34; alt=\u0026#34;Vue logo\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col\u0026#34;\u0026gt; \u0026lt;HelloWorld /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; EOF 安裝及配置 Electron 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 yarn add --dev electron concurrently wait-on cross-env electron-builder mkdir -p electron cat \u0026lt;\u0026lt; EOF \u0026gt; electron/main.cjs const { app, BrowserWindow } = require(\u0026#39;electron\u0026#39;) const path = require(\u0026#39;path\u0026#39;) const NODE_ENV = process.env.NODE_ENV function createWindow() { const mainWindow = new BrowserWindow({ width: 800, height: 600, show: false, autoHideMenuBar: true, webPreferences: { preload: path.join(__dirname, \u0026#39;preload.cjs\u0026#39;) } }) mainWindow.once(\u0026#39;ready-to-show\u0026#39;, () =\u0026gt; { mainWindow.show() }) mainWindow.loadURL( NODE_ENV === \u0026#39;development\u0026#39; ? \u0026#39;http://localhost:5173\u0026#39; : \\`file://\\${path.join(__dirname, \u0026#39;../dist/index.html\u0026#39;)}\\` ); if (NODE_ENV === \u0026#34;development\u0026#34;) { mainWindow.webContents.openDevTools() } } app.whenReady().then(() =\u0026gt; { createWindow() app.on(\u0026#39;activate\u0026#39;, function () { if (BrowserWindow.getAllWindows().length === 0) createWindow() }) }) app.on(\u0026#39;window-all-closed\u0026#39;, function () { if (process.platform !== \u0026#39;darwin\u0026#39;) app.quit() }) EOF cat \u0026lt;\u0026lt; EOF \u0026gt; electron/preload.cjs window.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, () =\u0026gt; { const replaceText = (selector, text) =\u0026gt; { const element = document.getElementById(selector) if (element) element.innerText = text } for (const dependency of [\u0026#39;chrome\u0026#39;, \u0026#39;node\u0026#39;, \u0026#39;electron\u0026#39;]) { replaceText(\\`\\${dependency}-version\\`, process.versions[dependency]) } }) EOF sed -i \u0026#39;/export default/a \\ \\ \\ \\ base: \u0026#34;./\u0026#34;,\u0026#39; vite.config.cjs sed -i \u0026#39;/version/a \u0026#34;main\u0026#34;: \u0026#34;electron/main.cjs\u0026#34;,\u0026#39; package.json sed -i \u0026#39;/\u0026#34;build/a \u0026#34;electron\u0026#34;: \u0026#34;wait-on tcp:5173 \u0026amp;\u0026amp; cross-env NODE_ENV=development electron .\u0026#34;,\u0026#39; package.json sed -i \u0026#39;/\u0026#34;build\u0026#34;:/a \u0026#34;electron:serve\u0026#34;: \u0026#34;concurrently -k \\\\\\\u0026#34;yarn dev\\\\\\\u0026#34; \\\\\\\u0026#34;yarn electron\\\\\\\u0026#34;\\\u0026#34;,\u0026#39; package.json sed -i \u0026#39;/\u0026#34;build\u0026#34;:/a \u0026#34;electron:build\u0026#34;: \u0026#34;vite build \u0026amp;\u0026amp; electron-builder\u0026#34;,\u0026#39; package.json sed -i \u0026#39;$d\u0026#39; package.json \u0026amp;\u0026amp; sed -i \u0026#39;$d\u0026#39; package.json \u0026amp;\u0026amp; cat \u0026lt;\u0026lt; EOF \u0026gt;\u0026gt; package.json }, \u0026#34;build\u0026#34;: { \u0026#34;appId\u0026#34;: \u0026#34;com.my-website.my-app\u0026#34;, \u0026#34;productName\u0026#34;: \u0026#34;MyApp\u0026#34;, \u0026#34;copyright\u0026#34;: \u0026#34;Copyright © 2022 Yuan\u0026#34;, \u0026#34;mac\u0026#34;: { \u0026#34;category\u0026#34;: \u0026#34;public.app-category.utilities\u0026#34; }, \u0026#34;nsis\u0026#34;: { \u0026#34;oneClick\u0026#34;: false, \u0026#34;allowToChangeInstallationDirectory\u0026#34;: true }, \u0026#34;files\u0026#34;: [ \u0026#34;dist/**/*\u0026#34;, \u0026#34;electron/**/*\u0026#34; ], \u0026#34;directories\u0026#34;: { \u0026#34;buildResources\u0026#34;: \u0026#34;assets\u0026#34;, \u0026#34;output\u0026#34;: \u0026#34;dist_electron\u0026#34; } } } EOF yarn electron:serve 修正安全提示中的 1 sed -i \u0026#39;/\u0026lt;meta name/a \\ \\ \\ \\ \\\u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;script-src \u0026#39;\\\u0026#39;\u0026#39;self\u0026#39;\\\u0026#39;\u0026#39;\u0026#34; /\\\u0026gt;\u0026#39; index.html Add Makefile 為了不用每次編譯時要下什麼指令，所以寫個 Makefile 省心 ~\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 TAB=\u0026#34;$(printf \u0026#39;\\t\u0026#39;)\u0026#34; cat \u0026lt;\u0026lt; EOF \u0026gt; Makefile all: run build: ${TAB}yarn electron:build .PHONY: web web: ${TAB}yarn dev .PHONY: run run: ${TAB}yarn electron:serve .PHONY: clean clean: ${TAB}\\$(RM) -r dist dist_electron EOF 額外記下來的 順手記下這次有用到的一些東西。\n使用 Axios 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 yarn add axios mkdir -p src/composables echo \u0026lt;\u0026lt; EOF \u0026gt; src/composables/useApi.js import axios from \u0026#39;axios\u0026#39;; const instance = axios.create({ baseURL: \u0026#39;http://localhost:8088/\u0026#39;, timeout: 1000, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, } }); const useAxios = ({url, method, arg}) =\u0026gt; { return instance[method](url, arg) } export default useAxios; EOF Electron 建立視窗後在背景做點事 1 2 3 4 5 6 7 app.on(\u0026#39;ready\u0026#39;, async () =\u0026gt; { const { execFile } = require(\u0026#39;child_process\u0026#39;) execFile(\u0026#39;./resources/server/CCSNoteServer.exe\u0026#39;) createWindow() }) const { ipcRenderer } = require(\u0026#39;electron\u0026#39;) 小結 筆都在這一篇快要完成的時候更新了 vite 的版本，從 vite 2.99 更新到 3.0.0。\n接下來世界就變了 🤣\nmigrate to ESM\nvite 預設使用的 Port 從 3000 改到了 5173。\ndev port\n修正後基本上只要把上面的指令直接貼在終端機中就可以了。\n最後附上執行結果！\n1 make screenshot\n參考連結 Vite+Electron快速构建一个VUE3桌面应用(一) [个人项目] 用 Electron + Vue3 + Golang 做个一个桌面 Markdown 笔记软件 electron12起，如何解决require is not defined的问题？ cawa-93/vite-electron-builder ","description":"","id":5,"section":"posts","tags":["go","vue","electron"],"title":"使用 Vue、Electron 以及 Go 建立一個小工具","uri":"https://e61983.github.io/2022-07-15-how-to-use-vue-electron-and-go-to-build-an-app/"},{"content":"前言 筆者已經習慣 vim 的輸入模式。所以在使用 VS Code 時，會安裝 vim 輸入模式的外掛。在鍵盤按鍵接住時，VS Code 卻不會連續輸入。本文主要就是要來解決這個問題。\n主要內容 解決方式 1 defaults write com.microsoft.VSCode ApplePressAndHoldEnabled -bool false 如果要復原的話，則只要改成 true 就可以了。\ndefaults write com.microsoft.VSCode ApplePressAndHoldEnabled -bool true 參考連結 macOS 长按连续输入的简单设置方法 ","description":"","id":6,"section":"posts","tags":["VSCode","MacOS"],"title":"如何解決在 MacOS VS Code 按鍵無法連續輸入的問題","uri":"https://e61983.github.io/2022-06-22-macos-hold-a-key-and-repeat-it-in-vscode/"},{"content":"前言 一開始為了收集、分析資料，筆者把所有的記錄都保存起來。隨著專案的進行我們只需要保留特定條件的記錄。想說就趁著這次順手記錄起來吧。\n主要內容 登入資料庫 1 psql -h myhost -d mydb -U myuser [-W] 列出所有資料表 1 postgres=# \\dt or\n1 2 3 4 5 SELECT * FROM pg_catalog.pg_tables WHERE 1 = 1 AND schemaname != \u0026#39;pg_catalog\u0026#39; AND schemaname != \u0026#39;information_schema\u0026#39;; 透過建立臨時表來刪除大量資料 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 BEGIN; SET LOCAL temp_buffers = \u0026#39;1000MB\u0026#39;; -- copy surviving rows into temporary table CREATE TEMP TABLE tmp AS SELECT u.* FROM users u WHERE u.id IS NULL; -- empty table TRUNCATE users; -- insert back surviving rows INSERT INTO users TABLE tmp; COMMIT; 如果途中有出現錯誤，則要使用 END; 進行退回 (Rollback)。 參考連結 Postgresql show tables Best way to delete millions of rows by id ","description":"","id":7,"section":"posts","tags":["postgresql"],"title":"如何在 Postgresql 資料庫中的刪除大量資料","uri":"https://e61983.github.io/2022-06-20-postgresql-delete-large-data/"},{"content":"前言 最近入手了新的 Unifi AP，趁這一次設定就順手記錄起來吧。\n主要內容 加入 Unifi 控制器 登入 Unifi AP ssh -l ubnt ${UNIFI_AP_ADDRESS}\t# password: ubnt 在 Unifi AP 沒有從 DHCP 取得 IP 之前，它的預設 IP 為 192.168.1.20。 指定要加入的 Unifi 控制器 set-inform http://${UNIFI_CONTROLLER_ADDRESS}:8080/inform 在控制器中點擊 [ Adpot ] 即可。\n變更 Unifi 控制器 在 Unfi 官方的文件中提到，我們可以透過 Unfi Network 來將 AP 重置為出廠設定。\nAll UniFi devices can be restored via their respective web or mobile applications. This is located in the “Manage” section of a device’s settings. Depending on the application, this may be referred to as “Forget”(UniFi Network) or “Unmanage” (UniFi Protect).\n接著就可以登入並加入 Unifi 控制器 [3] 了。\n補充 - 架設 Unfi Controller 我們可以使用 Docker 跟 docker-compose 來架設 Unfi Controller。\nversion: \u0026#34;2.1\u0026#34; services: unifi-controller: image: lscr.io/linuxserver/unifi-controller:version-7.1.66 container_name: unifi-controller environment: - PUID=1000 - PGID=1000 - MEM_LIMIT=1024 #optional - MEM_STARTUP=1024 #optional volumes: - ./config:/config ports: - 8443:8443 # Unifi web Admin port - 3478:3478/udp # Unifi STUN port - 10001:10001/udp # AP discovery - 8080:8080 # device communication - 1900:1900/udp #optional - 8843:8843 #optional - 8880:8880 #optional - 6789:6789 #optional - 5514:5514/udp #optional restart: unless-stopped 參考連結 UniFi - Problems with Device Adoption UniFi - How to Reset Devices to Factory Defaults linuxserver/unifi-controller ","description":"","id":8,"section":"posts","tags":["unifi"],"title":"如何設定 Unifi AP","uri":"https://e61983.github.io/2022-05-29-how-to-setup-unifi-ap/"},{"content":"前言 最近又要開始接觸到網頁的東西了!\n久沒有碰要再花一點時間回想。想說就趁著這次順手記錄起來吧。\n主要內容 寫在前面 本篇我們會透過 gin 框架建立 API 伺服器。一開始會先建立一個測試用的 API，接著在試著提供網頁服務後；我們會開始建立登入功能所需的 API login 以及 auth。\nlogin 會檢查登入所使用的帳戶密碼，在驗證正確後會給予 Token 於 Cookie 中。 auth 會檢查 Cookie 是否有合法的 Token 。 由於本篇主要是專注在網頁後端「如何使用 gin 框架」，所以有關 HTML、 JavaScript 、CSS 並不會著墨太多。\n建立專案 1 2 go mod init github.com/e61983/test-gin-login go get -u github.com/gin-gonic/gin 起手式 建立測試用的 API - ping 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 cat \u0026lt;\u0026lt; EOF \u0026gt; main.go package main import ( \u0026#34;net/http\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { r := gin.Default() r.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;pong\u0026#34;, }) }) r.Run() } EOF 現在讓我們先跑起來看看!\n1 go run main.go 並在另一個終端機上試著存取我們建立的 API ping\n1 2 3 4 curl -X GET http://localhost:8080/ping # Output: {\u0026#34;message\u0026#34;:\u0026#34;pong\u0026#34;}% 提供網頁服務 簡單的建立測試用的頁面。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 mkdir -p webroot cat \u0026lt;\u0026lt; EOF \u0026gt; webroot/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Home Page\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Home Page\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; EOF 接下來透過提供 LoadHTMLGlob() 載入文件夾中的靜態頁面。\n1 2 3 4 r.LoadHTMLGlob(\u0026#34;webroot/*\u0026#34;) r.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { c.HTML(http.StatusOK, \u0026#34;index.html\u0026#34;, gin.H{}) }) 重新運行後，使用瀏覽器觀看執行結果\n我們的第一個畫面\n登入 ( Login ) API 在使用 gin 的綁定 (binding) 功能時，我們要在想要綁定的欄位後面，依照想要綁定的方法加上 Struct Tags。\n之我們就可以使用 gin.Bind() 或是 gin.ShouldBind() 來取得網頁前端所傳輸的資料。\n本篇是用直接比對帳號密碼的方式實作，同學在實務上不要這樣學喔!\n在檢驗完之後，將 Token 記錄於 Cookie 。\n不過，目前常見驗證是採 JWT 的驗證方式，所以同學也自己來試著改寫看看。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 type User struct { Account string `json:\u0026#34;account\u0026#34; form:\u0026#34;account\u0026#34;` Password string `json:\u0026#34;password\u0026#34; form:\u0026#34;password\u0026#34;` } r.POST(\u0026#34;/login\u0026#34;, func(c *gin.Context) { /* 綁定資料 */ u := \u0026amp;User{} if c.ShouldBind(\u0026amp;u) != nil { c.JSON(http.StatusOK, gin.H{\u0026#34;err\u0026#34;: 1}) return } /* 檢查帳號密碼 */ if u.Account != TEST_ACCOUNT || u.Password != TEST_PASSWORD { c.JSON(http.StatusOK, gin.H{\u0026#34;err\u0026#34;: 2}) return } /* 將 Token 記錄於 Cookie 中 */ c.SetCookie(TOKEN_KEY, TEST_TOKEN, 3600, \u0026#34;/\u0026#34;, HOST, false, false) c.JSON(http.StatusOK, gin.H{}) }) 驗證 ( Auth ) API 我們可以從瀏覽器發送的請求中取出我們先前記錄於 Cookie 的 Token 。\n並且比對它是否合法。\n1 2 3 4 5 6 7 8 9 10 r.POST(\u0026#34;/auth\u0026#34;, func(c *gin.Context) { /* 從 Cookie 取出 Token */ if token, err := c.Cookie(TOKEN_KEY); err != nil { if TEST_TOKEN != token { c.JSON(http.StatusOK, gin.H{\u0026#34;err\u0026#34;: 2}) return } } c.JSON(http.StatusOK, gin.H{\u0026#34;err\u0026#34;: nil}) }) 建立登入表單與登入後顯示畫面 建立登入頁面。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 cat \u0026lt;\u0026lt; EOF \u0026gt; webroot/login.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;assets/core.css\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Login Page\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Login Page\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;form\u0026gt; \u0026lt;div class=\u0026#34;input-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt;Login\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;label\u0026#34; for=\u0026#34;account\u0026#34;\u0026gt;Account:\u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;account\u0026#34; name=\u0026#34;account\u0026#34; value=\u0026#34;tester\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;label\u0026#34; for=\u0026#34;password\u0026#34;\u0026gt;Password:\u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; id=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34; value=\u0026#34;test123\u0026#34; /\u0026gt; \u0026lt;button id=\u0026#34;btn\u0026#34; type=\u0026#34;button\u0026#34;\u0026gt; Submit \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; \u0026gt; import {getData, postData, getCookie, deleteCookie} from \u0026#39;/javascript/core.js\u0026#39;; function login() { let account = document.getElementById(\u0026#34;account\u0026#34;).value; let password = document.getElementById(\u0026#34;password\u0026#34;).value; postData(\u0026#34;http://localhost:8080/login\u0026#34;, {\u0026#34;account\u0026#34;: account, \u0026#34;password\u0026#34;: password}) .then(data=\u0026gt;{ console.log(data.err) if (data.err !== null){ window.location.replace(\u0026#34;/\u0026#34;) }else{ window.location.replace(\u0026#34;/admin/\u0026#34;) } }); } function check(token) { postData(\u0026#34;http://localhost:8080/auth\u0026#34;, {\u0026#34;token\u0026#34;: token}) .then(data=\u0026gt;{ if (data.err === null){ window.location.replace(\u0026#34;/admin/\u0026#34;) } }); } check(getCookie(\u0026#34;token\u0026#34;)) window.onload = function(){ document.getElementById(\u0026#34;btn\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, login); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; EOF 改寫歡迎畫面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 cat \u0026lt;\u0026lt; EOF \u0026gt; webroot/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;/assets/core.css\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Home Page\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Home Page\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;input-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt;Hello word\u0026lt;/div\u0026gt; \u0026lt;button id=\u0026#34;btn\u0026#34; type=\u0026#34;button\u0026#34;\u0026gt; Logout \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; \u0026gt; import {getData, postData, getCookie, deleteCookie} from \u0026#39;/javascript/core.js\u0026#39;; function logout() { deleteCookie(\u0026#34;token\u0026#34;, \u0026#34;/\u0026#34;, \u0026#34;localhost\u0026#34;) window.location.replace(\u0026#34;/\u0026#34;) } window.onload = function(){ document.getElementById(\u0026#34;btn\u0026#34;).addEventListener(\u0026#39;click\u0026#39;, logout); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; EOF 畫存取清界線 我們前面建立了將要顯示的頁面，現在我們要來設定存取的路徑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 /* 登入頁面 */ r.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { c.HTML(http.StatusOK, \u0026#34;login.html\u0026#34;, nil) }) /* 需要登入才能存取的頁面 */ admin := r.Group(\u0026#34;/admin\u0026#34;) admin.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { if currentUser, ok := c.Get(\u0026#34;User\u0026#34;); ok { log.Printf(\u0026#34;User [ %s ] Accessed\u0026#34;, currentUser) } c.HTML(http.StatusOK, \u0026#34;index.html\u0026#34;, nil) }) 建立中間層 雖然我們已經建立了 /login 與 /admin/ 這 2 個路徑，但如果我們直接在劉覽器中輸入 http://localhost:8080/admin/。會發現還是可以存取的。\n為了避免這樣的事情發生，我們可以建立中間層來檢查是否已登入。\n如果發現尚未登入的存取請求，我們就將其轉至登入畫面。\n1 2 3 4 5 6 7 8 9 10 11 12 13 func AuthMiddleware() gin.HandlerFunc { return func(c *gin.Context) { cookieToken, err := c.Cookie(TOKEN_KEY) if err != nil \u0026amp;\u0026amp; cookieToken != TEST_TOKEN { c.Redirect(http.StatusTemporaryRedirect, BASEURL) c.AbortWithStatus(http.StatusTemporaryRedirect) return } else { c.Set(\u0026#34;User\u0026#34;, TEST_ACCOUNT) c.Next() } } } 使用中間層 在我們建立好的 admin 路由群組中，使用我們建立好的中間層。如此一來，要存取此路由群組的請求就會檢查是否已登入了。\n1 admin.Use(AuthMiddleware()) 登入表單\n登入後歡迎畫面\n小結 本篇省略了很多實作上的細節，對被省略的部份有興趣的同學可以參考這裡。\n參考連結 gin-gonic/gin ","description":"","id":9,"section":"posts","tags":["go","gin","web backend","cookie"],"title":"使用 Gin 框架實作登入功能","uri":"https://e61983.github.io/2021-09-14-go-gin-web-backend/"},{"content":"前言 為了在之後開發過程中不用反覆燒寫 eMMC 與 SD 卡，本篇會設定 U-Boot 載入 Rootfs 以達到我們的目的。\n主要內容 寫在前面 我們這次的目標是從 NFS 伺服器中載入 Rootfs。所以我們在開機時，U-Boot 載入的 Kernel 與裝置樹 ( Devicetree ) 仍是 eMMC/SD 卡內的。\n在開機的過程中，首先會要把要執行的東西載入到記憶體中執行。\n所以我們可以預期，待會我們會需要載入 Kernel 與 裝置樹。\n最後才把主控權交給 Kernel。\n我們要做的就是在執行時期，修改 U-Boot 傳給 Kernel 的開機參數。\n配置 NFS 伺服器 這一個部份先前有筆記過了，如果還沒有看過的同學請參考這裡。\n分析 Kernel 與 Devicetree 的載入命令 U-Boot 預設開機在基本的初始化完成後，並且在指定的秒數內沒有都收到使用者的輸入，便會開始執行 bootcmd 中的內容。\n我們可以藉由分析它，來初步的知道系統的開機流程。\n1 2 3 4 print bootcmd # Output: bootcmd=mmc dev ${mmcdev}; if mmc rescan; then if run loadbootscript; then run bootscript; else if test ${sec_boot} = yes; then if run loadcntr; then run mmcboot; else run netboot; fi; else if run loadimage; then run mmcboot; else run netboot; fi; fi; fi; else booti ${loadaddr} - ${fdt_addr}; fi 整理過後, 我們可以觀察到它真正會執行到的指令為 run loadimage ，接著會是 run mmcboot 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 bootcmd= mmc dev ${mmcdev}; if mmc rescan; then if run loadbootscript; then run bootscript; else if test ${sec_boot} = yes; then if run loadcntr; then run mmcboot; else run netboot; fi; else if run loadimage; then run mmcboot; else run netboot; fi; fi; fi; else booti ${loadaddr} - ${fdt_addr}; fi 從 eMMC 中把 Kernel 載到記憶體裡面\n1 loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image} 繼續展開 mmcboot\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 mmcboot= echo Booting from mmc ...; run mmcargs; if test ${sec_boot} = yes; then if run auth_os; then run boot_os; else echo ERR: failed to authenticate; fi; else if test ${boot_fdt} = yes || test ${boot_fdt} = try; then if run loadfdt; then run boot_os; else echo WARN: Cannot load the DT; fi; else echo wait for boot; fi; fi; 從 eMMC 中把 裝置樹 ( Devicetree ) 載到記憶體裡面\n1 loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file} 開始載入 Kernel ，之後就會把控制權交給 Kernel 了。\n1 boot_os=booti ${loadaddr} - ${fdt_addr}; 我們可以使用 echo $? 來看返回值。 設定 U-Boot 環境變數 從先前的分析來看，比較重要的指令有:\nloadfdt loadimage boot_os 所以我們只要進行下列修改，即可。\n1 2 3 4 5 6 7 8 9 10 setenv serverip \u0026#34;NFS_SERVER_IP\u0026#34; setenv rootfs_dir \u0026#34;/srv/rootfs\u0026#34; setenv ethaddr \u0026#34;01:02:03:04:05:06\u0026#34; setenv image Image setenv fdt_file imx8qxp-mek-rpmsg.dtb setenv rootfsinfo \u0026#39;setenv bootargs ${bootargs} root=/dev/nfs ip=dhcp nfsroot=${serverip}:${rootfs_dir},v3,tcp\u0026#39; setenv bootcmd \u0026#39;run rootfsinfo; run loadfdt; run loadimage; run boot_os\u0026#39; saveenv 如我們想還原回預設值，可以使用下列指令\n1 2 env default -a saveenv 結果 我們可以重新啟動系統，或是直接執行 boot 就可以看到 U-Boot 正在開始執行我們剛才所撰寫的指令了。\n會發現，開機的時候有稍微變長了，並且在過程中可以看到 NFS 相關的字樣。\n開機完成後，我們可以在 /proc/cmdline 看到我們先前指定的開機參數(bootarg)。\n從 NFS 伺服器中載入 rootfs\n寫在最後 在 U-Boot 中看到的參數，在本篇並沒有多去探究。不過也別太過傷心，以後我們會專門製作一篇為大家講解。\n1 2 3 4 loadaddr=0x80280000 fdt_addr=0x83000000 image=Image fdt_file=imx8qxp-mek-rpmsg.dtb 小結 這次在撰寫本篇時，其實是想把 Kernel 與裝置樹都從網路載下來的。\n但礙於筆者的網路環境比較複雜，一直無法成功的藉由 TFTP 傳輸資料。\n所以也就暫時作罷。\n未來如果有完成這個部份再來更新吧。\n( 附上當時的筆記 )\n配置 TFTP 伺服器 安裝 TFTP 1 sudo aptitude install -y tftpd-hpa 配置分享路徑 1 2 3 4 5 6 7 sudo cp /etc/default/tftpd-hpa{,.bk} sudo sed -i \u0026#39;s#TFTP_DIRECTORY.*#TFTP_DIRECTORY=\u0026#34;/srv/tftp_shared\u0026#34;#g\u0026#39; /etc/default/tftpd-hpa sudo sed -i \u0026#39;s#TFTP_ADDRESS.*#TFTP_ADDRESS=\u0026#34;:69\u0026#34;#g\u0026#39; /etc/default/tftpd-hpa sudo sed -i \u0026#39;s#TFTP_OPTIONS.*#TFTP_OPTIONS=\u0026#34;--secure --create\u0026#34;#g\u0026#39; /etc/default/tftpd-hpa sudo systemctl enable tftpd-hpa sudo systemctl restart tftpd-hpa /etc/default/tftpd-hpa:\n1 2 3 4 5 # /etc/default/tftpd-hpa TFTP_USERNAME=\u0026#34;tftp\u0026#34; TFTP_DIRECTORY=\u0026#34;/srv/tftp_shared/\u0026#34; TFTP_ADDRESS=\u0026#34;:69\u0026#34; TFTP_OPTIONS=\u0026#34;--secure --create\u0026#34; 配置防火牆 1 2 3 4 sudo firewall-cmd \\ --add-rich-rule=\u0026#34;rule family=\u0026#39;ipv4\u0026#39; source address=\u0026#39;192.168.1.2\u0026#39; service name=\u0026#39;tftp\u0026#39; accept\u0026#34; \\ --permanent sudo firewall-cmd --reload 除錯 1 2 sudo netstat -nlp sudo journalctl -fu tftpd-hpa.service 用戶端測試 在伺服器中建立測試用的資料\necho \u0026#34;Hello word\u0026#34; \u0026gt; /srv/tftp_shared/hello 在用戶端進行上、下載測試\n1 2 3 4 5 echo \u0026#34;I am Groot~~~~~\u0026#34; \u0026gt; groot.txt tftp SERVER_IP tftp get hello tftp put groot.txt 參考連結 i.MX Linux® User\u0026rsquo;s Guide ","description":"","id":10,"section":"posts","tags":["i.mx8qxp","u-boot","yocto","linux","nfs","tftp"],"title":"在 i.MX 8QuadXPlus 上使用 Yocto 建置 Linux 系統 4","uri":"https://e61983.github.io/2021-09-13-yocto-with-imx8qxp-4/"},{"content":"前言 目前有了在外面存取 NAS 資料的需求，直接裸奔實在不是個明智的想法。還是放在防火牆後面，架個 VPN 服務好了。\n想說既然要架 VPN 伺服器。趁這次機會也一併換套防火牆軟體試試。\n主要內容 下載映像檔 選擇好想使用的映像檔後就可以直接下載下來，準備製作安裝隨身碟。\n下載頁面\n1 2 3 4 # Image Type: vga # Mirror: Nantou County Education Network center wget https://mirror.ntct.edu.tw/opnsense/releases/21.7/OPNsense-21.7.1-OpenSSL-vga-amd64.img.bz2 製作安裝隨身碟 在這裡我們使用 dd 來製作安裝隨身碟。如果是使用 Windows 系統的同學則嘗試使用 Rufs 來製作。\n1 bzcat OPNsense-21.7.1-OpenSSL-vga-amd64.img.bz2|sudo dd of=/dev/${DISK} bs=10m 安裝 Opnsense (參考影片) 使用我們剛製作完成的 Opnsense 安裝隨身碟開機後使用 installer/opnsense 帳戶登入，便可以開使進行安裝。\n下列整理了安裝的步驟\n安裝 Opnsense 系統 配置 WAN 配置 LAN 配置我們所需要的防火牆規則 設定 OpenVPN (參考影片) 下列整理了要架設 OpenVPN 的步驟\n建立 Root CA 建立 VPN 伺服器所要使用的憑證 ( Server-Cert ) 建立本機用戶所要使用的憑證 ( User-Cert ) 建立 OpenVPN Server，並添加防火牆規則 匯出 OpenVPN 使用者端的設定檔 最後，在終端設備安裝 OpenVPN 使用者程式並匯入設定檔(*.ovpn)。 小結 原本筆者是使用 pfSense 這套防火牆，所以在配置上其實 Opnsense 與 pfSense 差異沒有很大。\n不過外觀確實變得比較漂亮了🤣。\n參考連結 官方網站 官方文件 ","description":"","id":11,"section":"posts","tags":["vpn","openvpn","pfsense","opnsense"],"title":"安裝 Opnsense 並設定 OpenVPN","uri":"https://e61983.github.io/2021-09-09-install-opnsense-and-openvpn/"},{"content":"前言 UUU 全名為 Universal Update Utility。對 NXP i.MX 系列熟悉的使用者對 MFGTools 一定不會感到陌生，UUU 就是從 MFGTools 演進而來的，也稱為 MFGTools v3。它是用來進行 Freescale/NXP 晶片的映像檔燒錄。\n本篇將使用 UUU 將\u0008我們先前建立的映像檔燒寫至 eMMC 中。\n主要內容 寫在前面 為了要燒寫 bootloader 以及我們的系統至 eMMC，我們參考 IMX_LINUX_USERS_GUIDE.pdf 4.2.2 Using UUU\nFollow these instructions to use the UUU for i.MX 6, i.MX 7, i.MX 8:\nConnect a USB cable from a computer to the USB OTG/TYPE C port on the board. Connect a USB cable from the OTG-to-UART port to the computer for console output. Open a Terminal emulator program. See Section \u0026ldquo;Basic Terminal Setup\u0026rdquo; in this document. Set the boot pin to serial download mode mode. See Section \u0026ldquo;Serial download mode for the Manufacturing Tool\u0026rdquo; in this document. 燒寫前的準備 修改主板的 Boot 配置 將 boot mode 配置為 Serial Download Mode (1000)\n切換為 Serial Download\n連接 USB Type C 連接好 USB Type C 線到 Host 上。\nUSB Type C\n連接好 USB Type C 線之後，我們可以輸入下列指令來確認是否有連接上。\n1 2 3 4 5 6 7 8 9 10 ./uuu_mac -lsusb # Output # uuu (Universal Update Utility) for nxp imx chips -- libuuu_1.4.139-0-g1a8f760 # # Connected Known USB Devices #\tPath\tChip\tPro\tVid\tPid\tBcdVersion #\t================================================== #\t20:2\tMX8QXP\tSDPS:\t0x1FC9\t0x012F 0x0004 下載 UUU 筆者是使用 MacOS，所以下載時是下載 mac 的版本。\n1 2 3 wget https://github.com/NXPmicro/mfgtools/releases/download/uuu_1.4.139/uuu_mac chmod o+x uuu_mac ./uuu_mac dyld: Library not loaded: /usr/local/opt/libzip/lib/libzip.5.dylib\nReferenced from: /tmp/uuu_mac\nReason: image not found\n[1] 5351 abort ./uuu_mac\n解決的方式，就是安裝缺少的函式庫 libzip\n1 brew install libzip 燒寫 Bootloader 我們將輸入下列指令來使用 UUU 來寫入 U-Boot 到 eMMC 中。\n1 2 3 4 5 6 7 8 sudo ./uuu_mac -b emmc imx-boot-imx8qxpc0mek-sd.bin-flash_spl # Output # uuu (Universal Update Utility) for nxp imx chips -- libuuu_1.4.139-0-g1a8f760 # Success 1 Failure 0 # 20:433 7/ 7 [Done ] FB: Done 如果同學也遇到了這個問題，可以去使用最新的 libusb 函式庫。\nuuu (Universal Update Utility) for nxp imx chips \u0026ndash; libuuu_1.4.139-0-g1a8f760\nSuccess 0 Failure 1\n20:2 1/ 2 [Failure claim interface ] SDPS: boot -f \u0026ldquo;./u-boot-imx8qxpc0mek.bin-sd\u0026rdquo;\n1 2 3 4 # 參考 https://github.com/NXPmicro/mfgtools/issues/246#issuecomment-898894168 brew install --head libusb brew unlink libusb brew link --head libusb 燒寫整個系統 我們透過下列指令來寫入整個系統。\n1 2 3 4 5 6 7 8 sudo ./uuu_mac -b emmc_all imx-boot-imx8qxpc0mek-sd.bin-flash_spl \u0026#34;imx-image-core-imx8qxpc0mek.wic.bz2/*\u0026#34; # Output: # uuu (Universal Update Utility) for nxp imx chips -- libuuu_1.4.139-0-g1a8f760 # Success 1 Failure 0 # 20:433 8/ 8 [Done ] FB: done 在虛擬器中進行燒寫 如果同學們是使用虛擬器的環境，要特別注意 USB 埠的分享設定。記得如果有多個的話都要選到唷!\n虛擬器的USB 埠分享設定\n結果 將 boot mode 配置為 eMMC Mode (0100)，並重新開機之後即可看到與先前相同的輸出了。\n切換為 eMMC Mode\n小結 UUU 有支援 Fastboot 相關的指令，本篇並沒有太多的著墨。有興趣的同學可以自行玩玩看。\n參考連結 NXPmicro/mfgtools 【ATU Book-i.MX8系列】 UUU（Universal Update Utility） imx8mq - Bootloader 編譯過程 i.MX8 uuu ","description":"","id":12,"section":"posts","tags":["i.mx8qxp","yocto","linux"],"title":"在 i.MX 8QuadXPlus 上使用 Yocto 建置 Linux 系統 3","uri":"https://e61983.github.io/2021-09-07-yocto-with-imx8qxp-3/"},{"content":"前言 繼上一篇我們建立了可開機的映像檔後，接下來我們要來修改修改預設的除錯埠。從 UART0 改至 UART2。\n主要內容 寫在開始之前 在 Yocto 專案中，有關硬體的配置都會記錄在 Machine Layer。所以我們要先從 Machine 配置檔找到相關的資訊，再開始修改。\n在找到 u-boot 相關的資訊後，我們可能要修改:\n裝置樹 ( Devicetree ) GPIO初始化 (時序、iomux) 除錯埠相關設定 Kernel 開機參數 UART2 在哪裡 從主板上我們可以看到有一組 DB9 的連接埠，上面寫著 RS232。但我們要如何知道它是哪一個 UART 埠呢?\n主板上的 UART2\n我們可以從官方提供的電路圖來看，先找到 J37 (主板上有寫) 的元件。再從此開始一路的往源頭找。\nUART2 DB9\n電路圖\n最後我們可以看到它是接在 i.mx8qxp 的 AD34 與 AD35 上。\n電路圖\n我們可以看到 AD34 與 AD35 即是 UART2_RX 與 UART2_TX 。\ni.MX 8QuadXPlus and 8DualXPlus Automotive and Infotainment Applications Processors, P128\n也可以在參考手冊找到 UART2 的暫存器位置。\ni.MX 8DualX/8DualXPlus/8QuadXPlus Applications Processor Reference Manual, P31\n測試 UART2 是否正常 在這裡我們可以先將 boot 切換至 eMMC 並從新開機。\n連接好 i.mx8qxp 後，我們可以在 Host 端使用習慣的 RS232 工具軟體開啟 RS232 串列埠。\n接著在 i.mx8qxp 上配置好 UART2 的鮑率後，就可以進行測試了。\n如果主板的 eMMC 中並沒有可用的系統，關於這一點，以後我們會專門製作一篇為大家講解.。\n在 Host 端:\n1 screen /dev/tty.XXXXX 115200 在 i.mx8qxp 端:\n1 2 3 4 # 修改 ttyLP2 所使用的鮑率 stty -F /dev/ttyLP2 115200 echo \u0026#34;Hello Word!\u0026#34; \u0026gt; /dev//dev/ttyLP2 修改 U-Boot 來自 Machine Layer 的訊息 我們在上一篇是指定 imx8qxpc0mek 為目標機器，所以我們可以先找到此配置檔。\n1 2 3 4 5 cd imx-yocto-bsp/sources find . -iname \u0026#34;*imx8qxpc0mek*\u0026#34; # Output: # ./meta-imx/meta-bsp/conf/machine/imx8qxpc0mek.conf U-Boot 相關配置 在找到目標機器的配置檔後，我們可以找詢有關 VIRTUAL/BOOTLOADER 或是 VIRTUAL/UBOOT 相關的設定。\n如果沒有看到相關設定的話，我們可以再往它的 require 或是 include 檔查找。\n在 imx8qxp-mek.conf 我們知道了 U-Boot 的 defconfig 檔, 檔名為 imx8qxp_mek\nimx8qxp-mek.conf\nimx-yocto-bsp/sources/meta-imx/meta-bsp/conf/machine/imx8qxpc0mek.conf require imx-yocto-bsp/sources/meta-freescale/conf/machine/imx8qxp-mek.conf require imx-yocto-bsp/sources/meta-freescale/conf/machine/include/imx8x-mek.inc require imx-yocto-bsp/sources/meta-freescale/conf/machine/include/imx-base.inc 確認 U-Boot 套件資訊 我們可以透過找尋下列變數，來找到使用的 U-Boot Package 名稱。\nPREFERRED_PROVIDER_u-boot PREFERRED_PROVIDER_virtual/bootloader 在編譯過後，原始碼可以在 ${WORK_DIR} 資料夾中找到。\n1 2 3 4 5 6 7 8 ls imx-yocto-bsp/first-build/tmp/work/imx8qxpc0mek-poky-linux/u-boot-imx/1_2021.04-r0/git # Output: # api config.mk dts include MAINTAINERS scripts # arch configs env Kbuild Makefile test # board disk examples Kconfig net tools # cmd doc fs lib post # common drivers imx8qxp_mek_defconfig Licenses README 不過我們其實也可以直接使用 devshell ，在 devshell 環境進行修改就可以了。\n確認 U-Boot 開機時使用的裝置樹(Devicetree) 開機所使用的裝置樹資訊，會記錄在 defconfig 中，我們可以在 configs 中找詢 imx8qxp_mek_defconfig 配置檔。從配置檔中，我們可以看到它是使用 fsl-imx8qxp-mek。\n這個檔案我們可以在 /arch/arm/dts/ 中看到。\nimx8qxp_mek_defconfig\n修改 U-Boot 裝置樹(Devicetree) 在找尋的過程中發現 fsl-imx8qxp-ai_ml.dts 是使用 UART2 作為預設的輸出，所以我們可以參考它來進行修改。\n下列是我們會修改到的檔案:\narch/arm/dts/fsl-imx8dx.dtsi arch/arm/dts/fsl-imx8qxp-mek-u-boot.dtsi arch/arm/dts/fsl-imx8qxp-mek.dts 1 bitbake -c devshell virtual/bootloader 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 diff --git a/arch/arm/dts/fsl-imx8dx.dtsi b/arch/arm/dts/fsl-imx8dx.dtsi index a36bf388c7..4d2606defe 100644 --- a/arch/arm/dts/fsl-imx8dx.dtsi +++ b/arch/arm/dts/fsl-imx8dx.dtsi @@ -975,25 +975,7 @@ reg = \u0026lt;SC_R_UART_2\u0026gt;; #power-domain-cells = \u0026lt;0\u0026gt;; power-domains = \u0026lt;\u0026amp;pd_dma\u0026gt;; - #address-cells = \u0026lt;1\u0026gt;; - #size-cells = \u0026lt;0\u0026gt;; wakeup-irq = \u0026lt;347\u0026gt;; - - pd_dma2_chan12: PD_UART2_RX { - reg = \u0026lt;SC_R_DMA_2_CH12\u0026gt;; - power-domains =\u0026lt;\u0026amp;pd_dma_lpuart2\u0026gt;; - #power-domain-cells = \u0026lt;0\u0026gt;; - #address-cells = \u0026lt;1\u0026gt;; - #size-cells = \u0026lt;0\u0026gt;; - - pd_dma2_chan13: PD_UART2_TX { - reg = \u0026lt;SC_R_DMA_2_CH13\u0026gt;; - power-domains =\u0026lt;\u0026amp;pd_dma2_chan12\u0026gt;; - #power-domain-cells = \u0026lt;0\u0026gt;; - #address-cells = \u0026lt;1\u0026gt;; - #size-cells = \u0026lt;0\u0026gt;; - }; - }; }; pd_dma_lpuart3: PD_DMA_UART3 { reg = \u0026lt;SC_R_UART_3\u0026gt;; @@ -2839,10 +2821,7 @@ clock-names = \u0026#34;per\u0026#34;, \u0026#34;ipg\u0026#34;; assigned-clocks = \u0026lt;\u0026amp;clk IMX8QXP_UART2_CLK\u0026gt;; assigned-clock-rates = \u0026lt;80000000\u0026gt;; - power-domains = \u0026lt;\u0026amp;pd_dma2_chan13\u0026gt;; - dma-names = \u0026#34;tx\u0026#34;,\u0026#34;rx\u0026#34;; - dmas = \u0026lt;\u0026amp;edma2 13 0 0\u0026gt;, - \u0026lt;\u0026amp;edma2 12 0 1\u0026gt;; + power-domains = \u0026lt;\u0026amp;pd_dma_lpuart2\u0026gt;; status = \u0026#34;disabled\u0026#34;; }; diff --git a/arch/arm/dts/fsl-imx8qxp-mek-u-boot.dtsi b/arch/arm/dts/fsl-imx8qxp-mek-u-boot.dtsi index 5327485bfa..7df4d1bb5e 100644 --- a/arch/arm/dts/fsl-imx8qxp-mek-u-boot.dtsi +++ b/arch/arm/dts/fsl-imx8qxp-mek-u-boot.dtsi @@ -68,6 +68,10 @@ u-boot,dm-spl; }; +\u0026amp;pinctrl_lpuart2 { +\tu-boot,dm-spl; +}; + \u0026amp;pinctrl_usdhc1 { u-boot,dm-spl; }; @@ -136,6 +140,10 @@ u-boot,dm-spl; }; +\u0026amp;pd_dma_lpuart2 { +\tu-boot,dm-spl; +}; + \u0026amp;pd_conn_usbotg0 { u-boot,dm-spl; }; @@ -208,6 +216,10 @@ u-boot,dm-spl; }; +\u0026amp;lpuart2 { +\tu-boot,dm-spl; +}; + \u0026amp;usbmisc1 { u-boot,dm-spl; }; diff --git a/arch/arm/dts/fsl-imx8qxp-mek.dts b/arch/arm/dts/fsl-imx8qxp-mek.dts index 86aa868479..a5a5c5e49d 100644 --- a/arch/arm/dts/fsl-imx8qxp-mek.dts +++ b/arch/arm/dts/fsl-imx8qxp-mek.dts @@ -21,8 +21,8 @@ }; chosen { -\tbootargs = \u0026#34;console=ttyLP0,115200 earlycon\u0026#34;; -\tstdout-path = \u0026amp;lpuart0; +\tbootargs = \u0026#34;console=ttyLP2,115200 earlycon\u0026#34;; +\tstdout-path = \u0026amp;lpuart2; }; regulators { @@ -126,6 +126,13 @@ \u0026gt;; }; +\tpinctrl_lpuart2: lpuart2grp { +\tfsl,pins = \u0026lt; +\tSC_P_UART2_RX_ADMA_UART2_R\t0x06000020 +\tSC_P_UART2_TX_ADMA_UART2_T\t0x06000020 +\t\u0026gt;; +\t}; + pinctrl_usdhc1: usdhc1grp { fsl,pins = \u0026lt; SC_P_EMMC0_CLK_CONN_EMMC0_CLK\t0x06000041 @@ -217,6 +224,12 @@ status = \u0026#34;okay\u0026#34;; }; +\u0026amp;lpuart2 { +\tpinctrl-names = \u0026#34;default\u0026#34;; +\tpinctrl-0 = \u0026lt;\u0026amp;pinctrl_lpuart2\u0026gt;; +\tstatus = \u0026#34;okay\u0026#34;; +}; + \u0026amp;gpio0 { status = \u0026#34;okay\u0026#34;; }; fsl-imx8qxp-mek.dts include fsl-imx8qxp.dtsi include fsl-imx8dxp.dtsi include fsl-imx8dx.dtsi include fsl-imx8-ca35.dtsi Device tree\nThe U-Boot device tree is filtered by the fdtgrep tools during the build\nprocess to generate a much smaller device tree used in SPL (spl/u-boot-spl.dtb)\nwith:\nthe mandatory nodes (/alias, /chosen, /config) the nodes with one pre-relocation property:\n\u0026lsquo;u-boot,dm-pre-reloc\u0026rsquo; or \u0026lsquo;u-boot,dm-spl\u0026rsquo; fdtgrep is also used to remove:\nthe properties defined in CONFIG_OF_SPL_REMOVE_PROPS all the pre-relocation properties\n(\u0026lsquo;u-boot,dm-pre-reloc\u0026rsquo;, \u0026lsquo;u-boot,dm-spl\u0026rsquo; and \u0026lsquo;u-boot,dm-tpl\u0026rsquo;) All the nodes remaining in the SPL devicetree are bound\n(see doc/driver-model/design.rst).\n修改 U-Boot 開機配置 下列是我們會修改到的檔案:\narch/arm/mach-imx/imx8/clock.c board/freescale/imx8qxp_mek/imx8qxp_mek.c include/configs/imx8qxp_mek.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 diff --git a/arch/arm/mach-imx/imx8/clock.c b/arch/arm/mach-imx/imx8/clock.c index 4eb22ce129..05343d901d 100644 --- a/arch/arm/mach-imx/imx8/clock.c +++ b/arch/arm/mach-imx/imx8/clock.c @@ -27,7 +27,7 @@ u32 mxc_get_clock(enum mxc_clock clk) switch (clk) { case MXC_UART_CLK: err = sc_pm_get_clock_rate(-1, -\tSC_R_UART_0, 2, \u0026amp;clkrate); +\tSC_R_UART_2, 2, \u0026amp;clkrate); if (err != SC_ERR_NONE) { printf(\u0026#34;sc get UART clk failed! err=%d\\n\u0026#34;, err); return 0; diff --git a/board/freescale/imx8qxp_mek/imx8qxp_mek.c b/board/freescale/imx8qxp_mek/imx8qxp_mek.c index a4f9fab986..71068b090d 100644 --- a/board/freescale/imx8qxp_mek/imx8qxp_mek.c +++ b/board/freescale/imx8qxp_mek/imx8qxp_mek.c @@ -42,14 +42,14 @@ DECLARE_GLOBAL_DATA_PTR; (SC_PAD_28FDSOI_DSE_DV_HIGH \u0026lt;\u0026lt; PADRING_DSE_SHIFT) | \\ (SC_PAD_28FDSOI_PS_PU \u0026lt;\u0026lt; PADRING_PULL_SHIFT)) -static iomux_cfg_t uart0_pads[] = { -\tSC_P_UART0_RX | MUX_PAD_CTRL(UART_PAD_CTRL), -\tSC_P_UART0_TX | MUX_PAD_CTRL(UART_PAD_CTRL), +static iomux_cfg_t uart2_pads[] = { +\tSC_P_UART2_RX | MUX_PAD_CTRL(UART_PAD_CTRL), +\tSC_P_UART2_TX | MUX_PAD_CTRL(UART_PAD_CTRL), }; static void setup_iomux_uart(void) { -\timx8_iomux_setup_multiple_pads(uart0_pads, ARRAY_SIZE(uart0_pads)); +\timx8_iomux_setup_multiple_pads(uart2_pads, ARRAY_SIZE(uart2_pads)); } int board_early_init_f(void) @@ -57,8 +57,8 @@ int board_early_init_f(void) sc_pm_clock_rate_t rate = SC_80MHZ; int ret; -\t/* Set UART0 clock root to 80 MHz */ -\tret = sc_pm_setup_uart(SC_R_UART_0, rate); +\t/* Set uart2 clock root to 80 MHz */ +\tret = sc_pm_setup_uart(SC_R_UART_2, rate); if (ret) return ret; @@ -348,7 +348,7 @@ int board_init(void) void board_quiesce_devices(void) { const char *power_on_devices[] = { - \u0026#34;dma_lpuart0\u0026#34;, + \u0026#34;dma_lpuart2\u0026#34;, /* HIFI DSP boot */ \u0026#34;audio_sai0\u0026#34;, diff --git a/include/configs/imx8qxp_mek.h b/include/configs/imx8qxp_mek.h index 8e5e48026e..124cbc715c 100644 --- a/include/configs/imx8qxp_mek.h +++ b/include/configs/imx8qxp_mek.h @@ -30,7 +30,7 @@ #define CONFIG_SPL_BSS_MAX_SIZE\t0x1000\t/* 4 KB */ #define CONFIG_SYS_SPL_MALLOC_START\t0x82200000 #define CONFIG_SYS_SPL_MALLOC_SIZE 0x80000\t/* 512 KB */ -#define CONFIG_SERIAL_LPUART_BASE\t0x5a060000 +#define CONFIG_SERIAL_LPUART_BASE\t0x5a080000 /* use UART2 */ #define CONFIG_MALLOC_F_ADDR\t0x00138000 #define CONFIG_SPL_RAW_IMAGE_ARM_TRUSTED_FIRMWARE @@ -125,7 +125,7 @@ \u0026#34;script=boot.scr\\0\u0026#34; \\ \u0026#34;image=Image\\0\u0026#34; \\ \u0026#34;splashimage=0x9e000000\\0\u0026#34; \\ -\t\u0026#34;console=ttyLP0\\0\u0026#34; \\ +\t\u0026#34;console=ttyLP2\\0\u0026#34; \\ \u0026#34;fdt_addr=0x83000000\\0\u0026#34;\t\\ \u0026#34;fdt_high=0xffffffffffffffff\\0\u0026#34;\t\\ \u0026#34;cntr_addr=0x98000000\\0\u0026#34;\t\\ 建立 U-Boot 的 Patch 1 2 git diff \u0026gt; ${BUILD_DIR}/0001-UART0-to-UART2-modification.patch bitbake -c clean virtual/bootloader 修改 Kernel 修改完 Bootloader 的配置之後，接下來我們要修改 Kernel 的配置。\n我們可以透過找尋 PREFERRED_PROVIDER_virtual/kernel 變數，來找到使用的 Kernel Package 名稱 linux-fslc-imx。\n確認 Kernel 用的裝置樹(Devicetree) 我們可以看到 machine/imx8qxpc0mek.conf 中， KERNEL_DEVICETREE 變數記錄了許多裝置樹。\n但實際會使用哪一個來開機，會是在 u-boot 決定的。所以我們可以觀察 u-bbot 中的程式碼，最後會發它是使用 imx8qxp-mek.dtb 來開機的。\nimx8qxp_mek.c:412\n修改 Kernel 用的裝置樹(Devicetree) 1 bitbake -c devshell virtual/kernel 下列是我們會修改到的檔案:\narch/arm64/boot/dts/freescale/imx8x-mek.dtsi 1 2 3 4 5 6 7 8 9 10 11 12 13 14 --- diff --git a/arch/arm64/boot/dts/freescale/imx8x-mek.dtsi b/arch/arm64/boot/dts/freescale/imx8x-mek.dtsi index e7f348c2ad14..b08160c5832e 100644 --- a/arch/arm64/boot/dts/freescale/imx8x-mek.dtsi +++ b/arch/arm64/boot/dts/freescale/imx8x-mek.dtsi @@ -6,7 +6,7 @@ #include \u0026lt;dt-bindings/usb/pd.h\u0026gt; / { chosen { -\tstdout-path = \u0026amp;lpuart0; +\tstdout-path = \u0026amp;lpuart2; }; brcmfmac: brcmfmac { imx8x-mek.dts imx8x-mek.dtsi The chosen node\nThe chosen node does not represent a real device, but serves as a place\nfor passing data between firmware and the operating system, like boot\narguments. Data in the chosen node does not represent the hardware.\n(略)\nstdout-path\nDevice trees may specify the device to be used for boot console output\nwith a stdout-path property under /chosen, as described in the Devicetree\nSpecification，\u0008e.g.\n(略)\n建立 Kernel 的 Patch 1 2 git diff \u0026gt; ${BUILD_DIR}/0001-Kernel-UART0-to-UART2-modification.patch bitbake -c clean virtual/kernel 建立新的 Layer 並加入 Patch 1 2 3 4 5 6 7 8 9 # 建立新的 Layer - meta-first bitbake-layers create-layer meta-first # 使用 meta-first Layer bitbake-layers add-layer meta-first # 建立新的 recipe 用來加上我們前面的修改 recipetool appendsrcfile ../meta-first virtual/bootloader ../0001-UART0-to-UART2-modification.patch recipetool appendsrcfile ../meta-rtc virtual/kernel ../0001-Kernel-UART0-to-UART2-modification.patch 我們可以使用 bitbake-layers 來查看 bbappend 是否有發生作用。\n1 2 bitbake-layers show-appends bitbake -e virtual/bootloader 重新編譯映像檔並燒寫至 SD 卡 1 2 3 4 5 # 開始編譯 bitbake imx-image-core # 將映像檔寫入 SD 卡中 bzcat \u0026lt;image_name\u0026gt;.wic.bz2 | sudo dd of=/dev/sd\u0026lt;partition\u0026gt; bs=1M conv=fsync 結果 在接上 Host 與 主板上的 UART2 之後，我們重新啟動電源。\n從 UART2 看到 U-Boot 的輸出訊息\n可以看到開機的相關資訊已改從 UART2 輸出了。\n從 UART2 看到 U-Boot 的輸出訊息\n從 UART2 看到 Kernel 的輸出訊息\n小結 這一篇需要了解的東西比較多。除了 Yocto 本身之外，還要了解 U-Boot 的配置、Kernel 的配置、裝置樹以及 Kernel 的開機流程。\nYocto 可以參考 Yocto 基礎介紹 其他的部份，以後我們會再為大家進行說明。\n本篇所使用的 patch 就放在這提供給同學參考了。\n參考連結 var-MACHINEOVERRIDES [NXP i.MX 應用處理器教室] 在i.MX8QXP 平台更換偵錯的 UART接口 ","description":"","id":13,"section":"posts","tags":["i.mx8qxp","device tree","yocto","linux"],"title":"在 i.MX 8QuadXPlus 上使用 Yocto 建置 Linux 系統 2","uri":"https://e61983.github.io/2021-09-02-yocto-with-imx8qxp-2/"},{"content":"前言 突然有了移除 PDF 密碼保護的需求。在查找相關的資料時，順手記錄下來。\n主要內容 安裝 筆者是使用 MacBook ，所以本文在測試時會是在 MacOS 下進行。\n在 MacOS 中，可以輸入下列指令來安裝 qpdf。\n1 brew install qpdf 如果是使用 Ubuntu / Debian 系統，可以使用下列指令進行安裝\n1 sudo apt install -y qpdf 合併檔案 在點併檔案的時候，如果沒有輸入頁碼(範圍)的話，會將整份文件進行合併。\n1 qpdf --empty --pages 1.pdf 2.pdf 3.pdf -- out.pdf 我們可以在檔名後面加上指定的頁碼或是範圍\n1 qpdf --empty --pages doc1.pdf 1-2 doc2.pdf 1 doc1.pdf 3 -- out.pdf 移除密碼 使用下列指令來移除密碼保護。\n1 qpdf --decrypt crypt.pdf --password=${PASSWORD} decrypt.pdf 組合技 我們可以使用下列的指令以 doc1.pdf 第1頁、crypt.pdf、doc1.pdf 第2-3頁輸出為 out.pdf。\n1 qpdf --empty --pages doc1.pdf 1 crypt.pdf --password=${PASSWORD} doc2.pdf -- out.pdf 參考連結 qpdf/qpdf Syntax for merging entire PDF files ","description":"","id":14,"section":"posts","tags":["cli","pdf"],"title":"使用 qpdf 來合併 PDF 與移除密碼保護","uri":"https://e61983.github.io/2021-09-02-cli-remove-pdf-password/"},{"content":"前言 最近剛拿到 NXP 的 i.MAX8 開發板。在測試基本功能之餘，也順手把過程記錄下來。本文僅先建置 Yocto 的開發環境並編譯出可開機的映像檔，最後透過 SD 卡開機。\n主要內容 開發板配置 下列是來自官方的圖，我們主要會是以 SD Card 開機，所以目前我們要先確認主板的開機配置\nhttps://www.nxp.com/design/development-boards/i-mx-evaluation-and-development-boards/i-mx-8quadxplus-multisensory-enablement-kit-mek:MCIMX8QXP-CPU\n確認 SW2 的配置與下圖相同\nhttps://www.nxp.com/document/guide/get-started-with-the-mcimx8qxp-cpu:GS-MCIMX8QXP-CPU\n連接 J11 (Micro USB)，我們可以像先前一樣在電腦中看到 tty 裝置。在後續的流程，我們就可以透過它來操作系統。\nmicro USB Debug Port\n1 screen /dev/tty.XXXXXX 115200 安裝相依套件 1 2 3 4 5 6 7 8 9 sudo apt install -y gawk wget git-core diffstat unzip texinfo gcc-multilib \\ build-essential chrpath socat cpio python python3 python3-pip python3-pexpect \\ xz-utils debianutils iputils-ping python3-git python3-jinja2 libegl1-mesa libsdl1.2-dev \\ pylint3 xterm rsync curl mkdir -p ~/bin curl https://storage.googleapis.com/git-repo-downloads/repo \u0026gt; ~/bin/repo chmod a+x ~/bin/repo export PATH=~/bin:$PATH 建立 Yocto 環境 1 2 3 4 5 6 7 mkdir imx-yocto-bsp \u0026amp;\u0026amp; cd imx-yocto-bsp repo init -u https://source.codeaurora.org/external/imx/imx-manifest -b imx-linux-hardknott -m imx-5.10.35-2.0.0.xml # 這一步會花蠻多時間的，所以就讓子彈飛一會兒吧~~ repo sync DISTRO=fsl-imx-xwayland MACHINE=imx8qxpc0mek source imx-setup-release.sh -b first-build 第一次編譯 1 2 3 4 5 6 7 8 # 移至專案目錄中 cd first-build # 開始編譯 bitbake imx-image-core # 將映像檔寫入 SD 卡中 bzcat \u0026lt;image_name\u0026gt;.wic.bz2 | sudo dd of=/dev/sd\u0026lt;partition\u0026gt; bs=1M conv=fsync 測試 UART https://community.nxp.com/t5/i-MX-Processors/How-to-check-rs232-port-in-imx8-8x-baseboard-in-imx8qxp-mek/m-p/1240789\nNFS Host 端 在 Host 上安裝 NFS Server ，並進行分享目錄與防火牆設定。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 安裝 NFS Server aptitude install -y nfs-kernel-server # 建立分享目錄 mkdir -p /srv/nfs_shared # 設定分享目錄 echo \u0026#34;/srv/nfs_shared *(insecure,rw,sync,no_root_squash,subtree_check)\u0026#34; \u0026gt; /etc/export # 設定防火牆 (如果有的話) firewall-cmd --add-rich-rule=\u0026#34;rule family=\u0026#39;ipv4\u0026#39; source address=\u0026#39;192.168.0.10\u0026#39; service name=\u0026#39;nfs\u0026#39; accept\u0026#34; --permanent firewall-cmd --add-rich-rule=\u0026#34;rule family=\u0026#39;ipv4\u0026#39; source address=\u0026#39;192.168.0.10\u0026#39; service name=\u0026#39;mountd\u0026#39; accept\u0026#34; --permanent firewall-cmd --add-rich-rule=\u0026#34;rule family=\u0026#39;ipv4\u0026#39; source address=\u0026#39;192.168.0.10\u0026#39; service name=\u0026#39;rpc-bind accept\u0026#34; --permanent firewall-cmd --reload Client 端 在 i.mx8 開機後，後我們可以使用 ip 來檢視目前的 IP 配置狀況。\n1 2 3 4 ip -c addr # 設置靜態 IP ip addr add 192.168.0.10/24 dev eth0 1 2 mkdir -p /tmp/nfs mount -t nfs 192.168.0.2:/srv/nfs_shared /tmp/nfs 我們就可以存取到 Host 所分享的資料了。\n小結 在板子可以開機之後，接下來就要來試著改改看配置啦!\n參考連結 MCIMX8QXP-CPU 防火牆說明介紹 ","description":"","id":15,"section":"posts","tags":["i.mx8qxp","yocto","linux"],"title":"在 i.MX 8QuadXPlus 上使用 Yocto 建置 Linux 系統","uri":"https://e61983.github.io/2021-09-01-yocto-with-imx8qxp/"},{"content":"前言 最近剛好在重新安裝工作站，就順手記錄起來囉!\n主要內容 下載映像檔 1 wget https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/debian-11.0.0-amd64-netinst.iso 製作安裝碟 1 sudo dd if=debian-11.0.0-amd64-netinst.iso of=/dev/DISK bs=10M 安裝 安裝步驟可以參考這邊。\n設定 IP 使用 systemd-networkd 設定 IP 透過重新命名 /etc/network/interfaces 的方式，來停用原本的網路介面配置。並建立 systemd-networkd 的設定檔。\n完成後，我們就可以啟用 systemd-networkd 了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 取消 IPv6 echo \u0026#34;net.ipv6.conf.all.disable_ipv6 = 1\u0026#34; \u0026gt;\u0026gt; /etc/sysctl.conf mv /etc/network/interfaces{,.save} cat \u0026lt;\u0026lt; EOF \u0026gt;\u0026gt; /etc/systemd/network/lan.network [Match] Name=eth0 [Network] Address=192.168.0.2/24 Gateway=192.168.0.254 DNS=8.8.8.8 EOF systemctl enable systemd-networkd systemctl start systemd-networkd IP (已改用 systemd-networkd) 修改 /etc/network/interfaces 來設定主機的 IP\n1 2 3 4 5 6 7 allow-hotplug eth0 iface eth0 inet static address 192.168.0.2/24 gateway 192.168.0.254 # dns-* options are implemented by the resolvconf package, if installed dns-nameservers 8.8.8.8 dns-search happy.internal 使用下列指令來重新起動網路\n1 /etc/init.d/networking restart 1 2 3 auto eth0 allow-hotplug eth0 iface eth0 inet dhcp 我們可以使用下列指令來進行臨時的設定\n1 2 3 4 5 6 7 8 ip addr add 192.168.0.2/24 dev eth0 ip addr del 192.168.0.2/24 dev eth0 dhcp eth0 dhcp -r eth0 ip link set eth0 up ip link set eth0 down 安裝系統更新與常用工具 1 2 3 4 apt upgrade apt update apt install -y aptitude aptitude install -y silversearcher-ag vim htop 設定時間同步 1 2 3 4 5 6 7 8 cat \u0026lt;\u0026lt; EOF \u0026gt; /etc/systemd/timesyncd.conf [Time] NTP=time.google.com clock.stdtime.gov.tw EOF systemctl restart systemd-timesyncd.service timedatectl status date 設定防火牆規則 Firewalld aptitude install -y firewalld firewall-cmd --add-port=22022/tcp --permanent firewall-cmd --reload firewall-cmd --list-all 如果想直接操作 nftables 的話，可以使用下列指令\n1 2 3 4 5 systemctl enable nftables systemctl start nftables nft add rule inet filter input tcp dport 22 accept nft list ruleset #nft list table inet filter ufw (已改用 firewalld) 1 2 3 ufw enable ufw default deny ufw allow from XXX.XXX.XXX.XXX to XXX.XXX.XXX.XXX port 2234 proto tcp 修改 SSH Server 設定並上傳遠端存取公鑰 1 2 3 sed -i \u0026#39;s/^Port.*$/Port 2234/g\u0026#39; /etc/ssh/sshd_config systemctl restart ssh ssh-copy -i ~/.ssh/id_rsa XXX.XXX.XXX.XXX -p 2234 -l user 如果想要生成新的金鑰，可以輸入下列指令\n1 ssh-keygen -t rsa -b 4096 -f ~/.ssh/new_key_rsa -C email@example.com 限定只能使用金鑰進行認證 1 2 3 4 sed -i \u0026#39;s/^UsePAM.*$/UsePAM no/g\u0026#39; /etc/ssh/sshd_config sed -i \u0026#39;s/^PermitRootLogin.*$/PermitRootLogin no/g\u0026#39; /etc/ssh/sshd_config echo \u0026#39;PasswordAuthentication no\u0026#39; \u0026gt;\u0026gt; /etc/ssh/sshd_config systemctl restart ssh 如果是使用 sudo 的話，可以使用 tee 將輸出導向檔案\n1 echo \u0026#39;PasswordAuthentication no\u0026#39; | sudo tee -a /etc/ssh/sshd_config 查看有誰登入失敗以及有誰登入成功\n1 2 cat /var/log/auth.log | ag \u0026#39;sshd.*Invalid\u0026#39; cat /var/log/auth.log | ag \u0026#39;sshd.*opened\u0026#39; 擋掉登入失敗次數過多的連線 1 2 3 aptitude install -y fail2ban sed -e \u0026#39;s/^enabled = false$/enabled = true/g\u0026#39; /etc/fail2ban/jail.conf \u0026gt; /etc/fail2ban/jail.local systemctl enable fail2ban 我們可以使用 fail2ban-client 來查看目前的運行狀況\n1 fail2ban-client status 自動安裝更新 1 2 3 aptitude install -y unattended-upgrades dpkg-reconfigure -plow unattended-upgrades systemctl status unattended-upgrades.service logrotate 1 /etc/logrotate.conf 小結 本文記錄了系統在剛安裝完成時，要先進行的配置。如: IP、時間、防火牆等。\n未來若有再新增設定，會再補充說明。\n參考連結 Debian 官方網站 systemd-networkd How to install and configure firewalld on debian ","description":"","id":16,"section":"posts","tags":["linux","debian","server"],"title":"使用 Debian 來架設工作站","uri":"https://e61983.github.io/2021-08-31-install-debian-11/"},{"content":"前言 因為工作上的需求，最近接觸到了 GNSS 模組。\n維基百科是這樣說的。\n衛星導航系統（Global Navigation Satellite System, GNSS）是覆蓋全球的自主地利空間定位的衛星系統，允許小巧的電子接收器確定它的所在位置（經度、緯度和高度），並且經由衛星廣播沿著視線方向傳送的時間信號精確到10米的範圍內。接收機計算的精確時間以及位置，可以作為科學實驗的參考。\n主要內容 NEO M8N GPS模組 https://www.ruten.com.tw/item/show?21550304728186\nNEO-M8 Datasheet Page 6\nNMEA-0183 GGA 表示該語句為 GlobalPositioning System Fix Data(GGA) GPS定位信息\n\u0026lt;1\u0026gt; \u0026lt;2\u0026gt; \u0026lt;3\u0026gt; \u0026lt;4\u0026gt; \u0026lt;5\u0026gt; \u0026lt;6\u0026gt; \u0026lt;7\u0026gt; \u0026lt;8\u0026gt; \u0026lt;9\u0026gt; \u0026lt;10\u0026gt; \u0026lt;11\u0026gt; \u0026lt;12\u0026gt; UTC時間 緯度 緯度方向 經度 經度方向 GPS狀態指示 正在使用的衛星數量 HDOP水平精度因子 海平面高度 地球橢球面相對大地水準面的高度 差分GPS信息 差分站ID號 GLL 表示該語句為 Geographic Position(GLL) 地理定位信息\n\u0026lt;1\u0026gt; \u0026lt;2\u0026gt; \u0026lt;3\u0026gt; \u0026lt;4\u0026gt; \u0026lt;5\u0026gt; \u0026lt;6\u0026gt; \u0026lt;7\u0026gt; 緯度 緯度方向 經度 經度方向 UTC時間 定位狀態 校驗值 GSA 表示該語句為 GPSDOP and Active Satellites(GSA) 當前衛星信息\n\u0026lt;1\u0026gt; \u0026lt;2\u0026gt; \u0026lt;3\u0026gt; \u0026lt;4\u0026gt; \u0026lt;5\u0026gt; \u0026lt;6\u0026gt; 定位模式 當前狀態 PRN號 PDOP綜合位置精度因子 HDOP水平精度因子 VDOP垂直精度因子 GSV 表示該語句為 GPSSatellites in View(GSV) 可見衛星信息\n\u0026lt;1\u0026gt; \u0026lt;2\u0026gt; \u0026lt;3\u0026gt; \u0026lt;4\u0026gt; \u0026lt;5\u0026gt; \u0026lt;6\u0026gt; \u0026lt;7\u0026gt; GSV語句的總數目 當前GSV語句數目 顯示衛星的總數目 衛星的PRN號星號 衛星仰角 衛星鏇角 信噪比 MSS 表示該語句為 GPSSatellites in View(GSV) 可見衛星信息\nRMC 表示該語句為 RecommendedMinimum Specific GPS/TRANSIT Data(RMC) 推薦最小定位信息\n\u0026lt;1\u0026gt; \u0026lt;2\u0026gt; \u0026lt;3\u0026gt; \u0026lt;4\u0026gt; \u0026lt;5\u0026gt; \u0026lt;6\u0026gt; \u0026lt;7\u0026gt; \u0026lt;8\u0026gt; \u0026lt;9\u0026gt; \u0026lt;10\u0026gt; \u0026lt;11\u0026gt; 定位時UTC時間 狀態 緯度 緯度方向 經度 經度方向 速率,節 方位角 當前UTC日期 磁偏角 磁偏角方向 VTG 表示該語句為TrackMade Good and Ground Speed(VTG) 地面速度信息\n\u0026lt;1\u0026gt; \u0026lt;2\u0026gt; \u0026lt;3\u0026gt; \u0026lt;4\u0026gt; 真實方向 相對方向 步長 Knots 速率 km/h GNGGA，GPGGA，BDGGA 傻傻分不清楚 即“混合定位”（多衛星系統）、“GPS定位”、“北斗定位”\nBD,BDS: 北斗二代衛星系統 GP: GPS GL: GLONASS GA: Galileo GN: GNSS, 全球導航衛星系統 GPS模組輸出 連接方式 使用 micro USB 線進行連接\n指令 筆者是在 MacOS 的環境中進行測試的，只要打開終端機開啟正確的裝置即可。\n1 screen -L /dev/tty.XXXX 9600 硬體識別 在開始接收之後，一開始會顯示該模組的相關資訊:\nU-Blox 的歡迎訊息 硬體版本 在 FLASH 的韌體版本 在 ROM 的韌體版本 型號 通訊協定版本 GNSS 的配置 目前天線的配置 目前天線狀態 FLASH 資訊結構進入點 U-Blox 接收器配置 1 2 3 4 5 6 7 8 9 10 11 $GNTXT,01,01,02,u-blox AG - www.u-blox.com*4E // U-Blox 的歡迎訊息 $GNTXT,01,01,02,HW UBX-M80xx 00080000 *43 // 硬體版本 $GNTXT,01,01,02,EXT CORE 2.01 (75350) Oct 29 2013 16:15:41*5C // 在 FLASH 的韌體版本 $GNTXT,01,01,02,ROM BASE 2.01 (75331) Oct 29 2013 13:28:17*44 // 在 ROM 的韌體版本 $GNTXT,01,01,02,MOD NEO-M8N-0*7A // 型號 $GNTXT,01,01,02,PROTVER 15.00*01 // 通訊協定版本 $GNTXT,01,01,02,GNSS OTP: GPS GLO, SEL: GPS GLO*67 // GNSS配置 $GNTXT,01,01,02,ANTSUPERV=AC SD PDoS SR*3E // 目前天線的配置 $GNTXT,01,01,02,ANTSTATUS=OK*25 // 目前天線狀態 $GNTXT,01,01,02,FIS 0xEF4015 (79189) found*2D // FLASH 資訊結構進入點 $GNTXT,01,01,02,LLC FFFFFFFF-FFFFFFED-FFFFFFFF-FFFFFFFF-FFFFFF69*3E // U-Blox 接收器配置 定位資料 1 2 3 4 5 6 7 8 9 10 11 12 $GNRMC,054539.00,A,2524.04132,N,12130.71568,E,0.059,,200821,,,A*67 $GNVTG,,T,,M,0.059,N,0.109,K,A*39 $GNGGA,054539.00,2524.04132,N,12130.71568,E,1,09,1.82,35.1,M,17.8,M,,*75 $GNGSA,A,3,05,20,29,30,02,13,,,,,,,2.93,1.82,2.29*19 $GNGSA,A,3,87,72,71,,,,,,,,,,2.93,1.82,2.29*1A $GPGSV,4,1,13,02,63,084,43,05,49,332,43,06,26,113,,07,05,051,43*7F $GPGSV,4,2,13,11,52,086,,12,06,223,,13,76,177,21,15,46,226,16*74 $GPGSV,4,3,13,20,45,025,43,24,00,195,,25,02,252,,29,33,309,44*75 $GPGSV,4,4,13,30,21,081,42*44 $GLGSV,2,1,06,65,27,246,,71,36,015,34,72,58,301,28,85,30,146,*6B $GLGSV,2,2,06,86,79,105,,87,28,336,35*62 $GNGLL,2524.04132,N,12130.71568,E,054539.00,A,A*7B 座標轉換 由於模組的輸出是 $ddmm.mmmmm$ 格式，所以我們要再自行轉換為 $dd.dddddd$\n轉換方式: $ dd + \\dfrac {mm.mmmmm}{60} $\n例:\n假設我們收到的資料為 : 2524.04132N, 12130.71568E\n轉換的方式則為 $25 + \\dfrac {24.04132}{60} $, $121 + \\dfrac {30.71568}{60}$\n$ =\u0026gt; 25.4006886667, 121.511928$\n小結 本文僅先了解 GPS 模組基本輸出，尚未進行進一步的測試與研究。\n此外GPS模組輸出/定位資料章節的定位座標並非實際資料。\n參考連結 NEO M8N GPS模組 官方網站 NEO M8N 資料手冊 這應該是關於GPS定位寫得最詳實清晰的文章之一 ","description":"","id":17,"section":"posts","tags":["gps"],"title":"NEO M8N GPS模組","uri":"https://e61983.github.io/2021-08-20-gps-module/"},{"content":"前言 最近開始接觸到跟 GPS 有關的東西，想說順便把地理定位相關的資料整理起來。所以這一篇就這樣誕生啦。\n主要內容 地表上任何一個地理位置都可以用大地基準 ( Datum ) + 座標格式 ( Format ) 來表示。\n在台灣我們常聽到的 TWD67、TWD97、WGS84 就是大地基準。而大地座標、六度分帶(UTM)、二度分帶(TM2) 就是座標格式。\n大地基準 TWD67\n平面基準為1967年之參考橢球體(GRS67)，以南投埔里之虎子山為大地基準。\n橢球參數:長軸 a = 6378160m，扁率 $f = 298.25$ TWD97\n平面基準為1980年之參考橢球體(GRS80)，以八個衛星追蹤站為基準。\n橢球參數:長軸 a = 6378137m，扁率 $f = 298.257222101$ WGS84\n世界大地測量系統（英語：World Geodetic System, WGS），1984年的版本，也稱為 EPSG:4326。透過遍布世界的衛星觀測站觀測到的坐標建立，其精度為1~ 2m。\n地球的質量中心為中心點，加上世界各地的1500個地理座標參考點。\n橢球參數:長軸 a = 6378137m，扁率 $f = 298.257223563$ 參考橢球體\n$ a: 長軸 $\n$ b: 短軸 $\n$ f: 扁率 = \\frac{a-b}{a} $\n座標格式 大地座標\n經、緯度座標。以度、分、秒表示。(僅能表示位置與方向，無法直接表示距離)\nhttps://en.wikipedia.org/wiki/Local_tangent_plane_coordinates\n平面座標 (可以表示距離與面績)\nhttps://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system\n六度分帶 ( Universal Transverse Mercator, UTM)\n橫麥卡托六度分帶\n二度分帶 (TM2)\n橫麥卡托二度分帶\n座標轉換 TWD97 轉 TWD67 (平面四參數轉換:僅適用台灣本島，最大誤差約2公尺) $X_{67} =X_{97} - 807.8 - AX_{97} - BY_{97}$\n$Y_{67} = Y_{97} + 248.6 - AY_{97} - BX_{97}$\n$A = 0.00001549$\n$B = 0.000006521$\nTWD67 轉 TWD97 (平面四參數轉換:僅適用台灣本島，最大誤差約2公尺) $X_{97} = X_{67} + 807.8 + AX_{67} + BY_{67}$\n$Y_{97} =Y_{67} - 248.6 + AY_{67} + BX_{67}$\n$A = 0.00001549$\n$B = 0.000006521$\n實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) const ( a float64 = 6378137.0 b float64 = 6356752.3142451 lon0 float64 = 121 * math.Pi / 180 k0 float64 = 0.9999 dx float64 = 250000 dy float64 = 0 ) var ( e float64 = 1 - math.Pow(b, 2)/math.Pow(a, 2) e2 float64 = (1 - math.Pow(b, 2)/math.Pow(a, 2)) / (math.Pow(b, 2) / math.Pow(a, 2)) ) func LonLat2TM2(lon, lat float64) (x, y float64) { lon = (lon - math.Floor((lon+180)/360)*360) * math.Pi / 180 lat = lat * math.Pi / 180 V := a / math.Sqrt(1-e*math.Pow(math.Sin(lat), 2)) T := math.Pow(math.Tan(lat), 2) C := e2 * math.Pow(math.Cos(lat), 2) A := math.Cos(lat) * (lon - lon0) M := a * ((1.0-e/4.0-3.0*math.Pow(e, 2)/64.0-5.0*math.Pow(e, 3)/256.0)*lat - (3.0*e/8.0+3.0*math.Pow(e, 2)/32.0+45.0*math.Pow(e, 3)/1024.0)* math.Sin(2.0*lat) + (15.0*math.Pow(e, 2)/256.0+45.0*math.Pow(e, 3)/1024.0)* math.Sin(4.0*lat) - (35.0*math.Pow(e, 3)/3072.0)*math.Sin(6.0*lat)) x = dx + k0*V*(A+(1-T+C)*math.Pow(A, 3)/6+ (5-18*T+math.Pow(T, 2)+72*C-58*e2)*math.Pow(A, 5)/120) y = dy + k0*(M+V*math.Tan(lat)*(math.Pow(A, 2)/2+(5-T+9*C+4*math.Pow(C, 2))*math.Pow(A, 4)/24+ (61-58*T+math.Pow(T, 2)+600*C-330*e2)*math.Pow(A, 6)/720)) return } func TM22LonLat(x, y float64) (lon, lat float64) { x -= dx y -= dy // Calculate the Meridional Arc M := y / k0 // Calculate Footprint Latitude mu := M / (a * (1.0 - e/4.0 - 3*math.Pow(e, 2)/64.0 - 5*math.Pow(e, 3)/256.0)) e1 := (1.0 - math.Sqrt(1.0-e)) / (1.0 + math.Sqrt(1.0-e)) J1 := (3*e1/2 - 27*math.Pow(e1, 3)/32.0) J2 := (21*math.Pow(e1, 2)/16 - 55*math.Pow(e1, 4)/32.0) J3 := (151 * math.Pow(e1, 3) / 96.0) J4 := (1097 * math.Pow(e1, 4) / 512.0) fp := mu + J1*math.Sin(2*mu) + J2*math.Sin(4*mu) + J3*math.Sin(6*mu) + J4*math.Sin(8*mu) // Calculate Latitude and Longitude C1 := e2 * math.Pow(math.Cos(fp), 2) T1 := math.Pow(math.Tan(fp), 2) R1 := a * (1 - e) / math.Pow((1-e*math.Pow(math.Sin(fp), 2)), (3.0/2.0)) N1 := a / math.Pow((1-e*math.Pow(math.Sin(fp), 2)), 0.5) D := x / (N1 * k0) // 計算緯度 Q1 := N1 * math.Tan(fp) / R1 Q2 := (math.Pow(D, 2) / 2.0) Q3 := (5 + 3*T1 + 10*C1 - 4*math.Pow(C1, 2) - 9*e2) * math.Pow(D, 4) / 24.0 Q4 := (61 + 90*T1 + 298*C1 + 45*math.Pow(T1, 2) - 3*math.Pow(C1, 2) - 252*e2) * math.Pow(D, 6) / 720.0 lat = fp - Q1*(Q2-Q3+Q4) // 計算經度 Q5 := D Q6 := (1 + 2*T1 + C1) * math.Pow(D, 3) / 6 Q7 := (5 - 2*C1 + 28*T1 - 3*math.Pow(C1, 2) + 8*e2 + 24*math.Pow(T1, 2)) * math.Pow(D, 5) / 120.0 lon = lon0 + (Q5-Q6+Q7)/math.Cos(fp) lat = (lat * 180) / math.Pi //緯 lon = (lon * 180) / math.Pi //經 return } func TWD672TWD97(x, y float64) (x_97, y_97 float64) { const A float64 = 0.00001549 const B float64 = 0.000006521 x_97 = x + 807.8 + A*x + B*y y_97 = y - 248.6 + A*y + B*x return } func TWD972TWD67(x, y float64) (x_67, y_67 float64) { const A float64 = 0.00001549 const B float64 = 0.000006521 x_67 = x - 807.8 - A*x - B*y y_67 = y + 248.6 - A*y - B*x return } // References: // https://www.sunriver.com.tw/taiwanmap/grid_tm2_convert.php func main() { const x_67 float64 = 247342 const y_67 float64 = 2652336 x_97, y_97 := TWD672TWD97(x_67, y_67) fmt.Printf(\u0026#34;TWD67:\\n\u0026#34;) fmt.Printf(\u0026#34;\\t%f, %f\\n\u0026#34;, x_67, y_67) fmt.Printf(\u0026#34;TWD97:\\n\u0026#34;) fmt.Printf(\u0026#34;\\t%f, %f\\n\u0026#34;, x_97, y_97) lon, lat := TM22LonLat(x_97, y_97) fmt.Printf(\u0026#34;LonLat:\\n\u0026#34;) fmt.Printf(\u0026#34;\\t%f, %f\\n\u0026#34;, lon, lat) } /* Output: TWD67: 247342.000000, 2652336.000000 TWD97: 248170.927211, 2652130.097602 LonLat: 120.982026, 23.973876 */ 小結 台灣使用的座標表示法，想不到裡面有這麼多歷史可以探究。筆者看完許多資料後，推薦有興趣的同學可以看一看 Taiwan datums ，裡面干貨滿滿 !!\n另外，本最後的實作主要是參考 大胖子與小個子的部落格 的程式，並以 Go 改寫。\n感謝前人的整理與貢獻!\n參考連結 大地座標系統漫談 Taiwan datums 大胖子與小個子的部落格 國立成功大學水工試驗所 坐標系統 ","description":"","id":18,"section":"posts","tags":["geo","gps","go"],"title":"在台灣常見的地理位置表示方式","uri":"https://e61983.github.io/2021-08-19-gps-format/"},{"content":"前言 繼先前建立好基楚的系統後，我們已經加入了 bootlinlabs machine。\n本文會接續之前建立的環境，開始加入自訂的 Image。\n主要內容 Image Image 就是 root filesystem。它會放置於 meta*/recipes*/images/*.bb 中。\nPoky 預設的 Image core-image-base\n只提供 Console 的環境，並且支援所有硬體功能。 core-image-minimal\n只提供 Console 的環境，並且只滿足開機的須求。 core-image-minimal-dev\n同 core-image-minimal，但又支援額外的開發用工具。 core-image-x11\n提供 X11 圖形化介面。 core-iamge-rt\n同 core-image-minimal, 但額外提供 Real Time 相關工具。 Image 常見的配置項 IMAGE_BASENAME\n輸出的映像檔名稱，預設為 ${PN} IMAGE_INSTALL\n要安裝於此映像檔的 Package / Package groups IMAGE_ROOTFS_SIZE\n最終的 Root filesystem 大小 IMAGE_FEATURES\n提供的特性清單 IMAGE_FSTYPES\n要產生的映像檔種類，例: ext2, ext3, squashfs, cpio, jffs2, ubifs, \u0026hellip; 等。\n可參考 meta/classes/image_types.bbclass IMAGE_LINGUAS\n此映像檔所支援的語言 IMAGE_PKGTYPE\n此映像檔所使用的套件安裝種類，例: deb, rpm, ipk, tar IMAGE_POSTPROCESS_COMMAND\n在最後想要執行的 shell 指令 WIC wic 是一個用來建置可燒寫的映像檔。它可以透過 .wks 或是 .wks.in 來建立分隔區、指定檔案位置。\n相關的配置如:\n1 2 WKS_FILE = \u0026#34;imx-uboot-custom.wks.in\u0026#34; IMAGE_FSTYPES = \u0026#34;wic.bmp wic\u0026#34; imx-uboot-custom.wks.in:\n1 2 3 4 5 6 part u-boot --source rawcopy --sourceparams=\u0026#34;file=imx-boot\u0026#34; --ondisk sda --no-table --align ${IMX_BOOT_SEEK} part /boot --source bootimg-partition --ondisk sda --fstype=vfat --label boot --active --align 8192 --size 64 part / --source rootfs --ondisk sda --fstype=ext4 --label root --exclude-path=home/ --exclude-path=opt/ --align 8192 part /home --source rootfs --rootfs-dir=${IMAGE_ROOTFS}/home --ondisk sda --fstype=ext4 --label home --align 8192 part /opt --source rootfs --rootfs-dir=${IMAGE_ROOTFS}/opt --ondisk sda --fstype=ext4 --label opt --align 8192 bootloader --ptable msdos Package Groups 用來將 Package 依其功能進行分類。通常我們可以在 meta*/recipes-core/packagegroups/ 找到，它們會是以 packagegroup- 做為前綴來命名。如: packagegroup-core-boot，packagegroup-core-nfs-server。\n實際撰寫時，只要繼承 packagegroup 即可。例:\n1 2 3 4 5 6 7 SUMMARY = \u0026#34;Debugging tools\u0026#34; LICENSE = \u0026#34;MIT\u0026#34; inherit packagegroup RDEPENDS_${PN} = \u0026#34;\\ gdb \\ gdbserver \\ strace\u0026#34; 建立 bootlinlabs-image-minimal 1 2 3 4 5 6 7 8 pushd ./meta-bootlinlabs mkdir -p recipes-image/images echo \u0026#39;IMAGE_INSTALL = \u0026#34;packagegroup-core-boot\u0026#34;\u0026#39; \u0026gt;\u0026gt; recipes-image/images/bootlinlabs-image-minimal.bb echo \u0026#39;inherit core-image\u0026#39; \u0026gt;\u0026gt; recipes-image/images/bootlinlabs-image-minimal.bb echo \u0026#39;\u0026#39; \u0026gt;\u0026gt; recipes-image/images/bootlinlabs-image-minimal.bb echo \u0026#39;IMAGE_INSTALL_append = \u0026#34; dropbear ninvaders\u0026#34;\u0026#39; \u0026gt;\u0026gt; recipes-image/images/bootlinlabs-image-minimal.bb popd bitbake bootlinlabs-image-minimal 更新 NFS 分享目錄\nsudo tar xpf tmp/deploy/images/bootlinlabs/bootlinlabs-image-minimal-stm32mp1.tar.xz -C /nfs_shared/ 重新啟重 STM32MP1\nbootlinlabs-image-minimal\n小結 參考連結 Customizing Images using Custom bb Files Bootlin/Yocto with STM32 Bootlin/Yocto with STM32 Lab ","description":"","id":19,"section":"posts","tags":["stm32mp1","yocto","linux"],"title":"在 STM32MP1 上使用 Yocto 建置 Linux 系統 4","uri":"https://e61983.github.io/2021-08-12-stm32mp-with-yocto-4/"},{"content":"前言 繼先前建立好基楚的系統後，我們已經加入了 meta-bootlinlabs Layer。\n本文會接續之前建立的環境，開始加入自訂的 Machine。\n主要內容 BSP Layer BSP Layer 是 Layer 的一種，它通常會包含目標機器的硬體配置、Bootloader、Kernel、Display Support。常以 meta-\u0026lt;bsp-name\u0026gt; 命名，裡面會有 machnes 資料夾。\n如果我們想知道該 BSP Layer 它支援了哪些機器，我們可以在該 Layer 中，觀察它的 conf/machine/*.conf。\n目標機器的配置檔會以 MACHINE.conf 命名。\n但更好的方式是，該 BSP Layer 有完善的 README，讓我們可以直接參考。\nMachine 常見的配置項 TARGET_ARCH\n該機器的硬體架構，例: arm, aarch64 PREFERRED_PROVIDER_virtual/kernel\n預設使用的 Kernel MACHINE_FEATURES\n提供的硬體特性清單，例: usbgadget, usbhost, screen, wifi, bluetooth SERIAL_CONSOLES\n要使用的序列埠與通訊速度，它會被傳給Kernel 做為 console 的參數。例: 115200;ttyS0 KERNEL_IMAGETYPE\n要編譯的映像檔種類，例: zImage, uImage Bootloader 常見的配置項 SPL_BINARY\n如果有 SPL (Secondary Program Loader)，指定此 SPL 的名稱。預設是空字串。 UBOOT_SUFFIX\nUBOOT的後綴，例: img。預設是 bin。 UBOOT_MACHINE\n目前機器所使用的配置檔。 UBOOT_ENTRYPOINT\nBootloader 的進入點。例: 0xC0800000 UBOOT_LOADADDRESS\nBootloader 載入位置。 UBOOT_MAKE_TARGET\nMakefile 的目標，預設是 all Kernel 常見的配置項 Kernel 的配置也會撰寫在 \u0026lt;machine\u0026gt;.conf 中\nPREFERRED_PROVIDER_virtual/kernel\n指定要使用的 Kerenl Package PREFERRED_VERSION_linux-yocto = \u0026ldquo;5.10%\u0026rdquo;\n指定要使用的版本 SRC_URL\n必須提供 Kernel 配置檔，並命名為 defconfig。 SRC_URL += \u0026#34;file://defconfig\t\\ file://nand-support.cfg\t\\ file://ethernet-support.cfg \\ \u0026#34; Kernel Metadata 常見的配置項 LINUX_KERNEL_TYPE standard (預設) tiny preempt-rt KERNEL_FEATURES\n提供的 Kernel 特性清單 資料夾結構\nbsp/ cfg/ features/\n例: features/smp.scc\nKERNEL_FEATURES += \u0026ldquo;features/smp.scc\u0026rdquo; 1 2 3 define KFEATURE_DESCRIPTION \u0026#34;Enable SMP\u0026#34; kconf hardware smp.cfg patch smp-support.patch ktypes/ patches/ 調整 Kernel 配置 調整 Kernel 配置時，我們可以以提供 defconfig 的方式進行。或是提供 Configure Fragments 進行調整。\n提供 defconfig 1 2 3 4 5 6 7 8 9 10 # 配置 Kernel bitbake -c kernel_configme linux-yocto # 手動調整 Kernel 選項 bitbake -c menuconfig linux-yocto # 產生 .config bitbake -c savedefconfig linux-yocto # 我們再自行將 .confg 存為 defconfig 提供 Configure Fragments 1 2 3 4 5 6 7 8 9 10 11 # 配置 Kernel bitbake -c kernel_configme linux-yocto # 手動調整 Kernel 選項 bitbake -c menuconfig linux-yocto # 產生 Configure Fragments bitbake -c diffconfig linux-yocto # 確認 Configure Fragments 是否有正確被套用 bitbake -c kernel_configcheck -f linux-yocto 建立 bootlinlabs Machine 我們可以參考 meta-st-stm32mp/conf/machine 的配置進行 bootlinlabs Machine 的建立。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 pushd ../meta-bootlinlabs # 建立 machine 資料夾 mkdir conf/machine # 建立 bootlinlabs 配置檔 echo \u0026#39;require conf/machine/include/st-machine-common-stm32mp.inc\u0026#39; \u0026gt;\u0026gt; conf/machine/bootlinlabs.conf echo \u0026#39;require conf/machine/include/st-machine-providers-stm32mp.inc\u0026#39; \u0026gt;\u0026gt; conf/machine/bootlinlabs.conf echo \u0026#39;\u0026#39; \u0026gt;\u0026gt; conf/machine/bootlinlabs.conf echo \u0026#39;DEFAULTTUNE = \u0026#34;cortexa7thf-neon-vfpv4\u0026#34;\u0026#39; \u0026gt;\u0026gt; conf/machine/bootlinlabs.conf echo \u0026#39;require conf/machine/include/tune-cortexa7.inc\u0026#39; \u0026gt;\u0026gt; conf/machine/bootlinlabs.conf echo \u0026#39;\u0026#39; \u0026gt;\u0026gt; conf/machine/bootlinlabs.conf echo \u0026#39;BOOTSCHEME_LABELS += \u0026#34;trusted\u0026#34;\u0026#39; \u0026gt;\u0026gt; conf/machine/bootlinlabs.conf echo \u0026#39;STM32MP_DT_FILES_DK += \u0026#34;stm32mp157f-dk2\u0026#34;\u0026#39; \u0026gt;\u0026gt; conf/machine/bootlinlabs.conf echo \u0026#39;FLASHLAYOUT_CONFIG_LABELS += \u0026#34;sdcard\u0026#34;\u0026#39; \u0026gt;\u0026gt; conf/machine/bootlinlabs.conf popd 修改 conf/local.conf 內的 MACHINE，並重新編譯。\n1 2 sed -i \u0026#39;s/^MACHINE.*/MACHINE ?= \u0026#34;bootlinlabs\u0026#34;/g\u0026#39; conf/local.conf bitbake core-image-minimal 我們可以在 ${BUILDDIR}/tmp/deploy/images/**bootlinlabs**/ 看到我們所建立的新 Machine。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 $ ls tmp/deploy/images/bootlinlabs/ arm-trusted-firmware bootloader core-image-minimal-bootlinlabs-20210812144202_nand_4_256_multivolume.rootfs.ubi core-image-minimal-bootlinlabs-20210812144202_nand_4_256_multivolume.ubinize.cfg.ubi core-image-minimal-bootlinlabs-20210812144202_nand_4_256.rootfs.ubi core-image-minimal-bootlinlabs-20210812144202_nand_4_256.rootfs.ubifs core-image-minimal-bootlinlabs-20210812144202_nand_4_256.ubinize.cfg.ubi core-image-minimal-bootlinlabs-20210812144202.rootfs.ext4 core-image-minimal-bootlinlabs-20210812144202.rootfs.manifest core-image-minimal-bootlinlabs-20210812144202.rootfs.tar.xz core-image-minimal-bootlinlabs-20210812144202.testdata.json core-image-minimal-bootlinlabs.ext4 core-image-minimal-bootlinlabs.manifest core-image-minimal-bootlinlabs_nand_4_256_multivolume.ubi core-image-minimal-bootlinlabs_nand_4_256_multivolume.ubinize.cfg.ubi core-image-minimal-bootlinlabs_nand_4_256.ubi core-image-minimal-bootlinlabs_nand_4_256.ubifs core-image-minimal-bootlinlabs_nand_4_256.ubinize.cfg.ubi core-image-minimal-bootlinlabs.tar.xz core-image-minimal-bootlinlabs.testdata.json flashlayout_core-image-minimal kernel scripts Distro Layer 通常 Distro Layer 會包含 Libc，initialization script, splash screen, \u0026hellip; 等, 相關的配置會記錄在 conf/distro/\u0026lt;distro\u0026gt;.conf 中。\n在 \u0026lt;distro\u0026gt;.conf 中必須包含 DISTRO 變數。例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 require conf/distro/poky.conf DISTRO = \u0026#34;distro\u0026#34; DISTRO_NAME = \u0026#34;distro description\u0026#34; DISTRO_VERSTION = \u0026#34;1.0\u0026#34; MAINTAINER = \u0026#34;...\u0026#34; # 提供的特性清單 DISTRO_FEATURES = \u0026#34;...\u0026#34; # 提供的特性清單，它同時會作用在 MACHINE_FEATURES COMBINED_FEATURES = \u0026#34;...\u0026#34; # Toolchain TCMODE = \u0026#34;...\u0026#34; 小結 本次實做的部份比較少，重心主要放在瞭解 machine，distro 的配置。\n參考連結 Bootlin/Yocto with STM32 Bootlin/Yocto with STM32 Lab ","description":"","id":20,"section":"posts","tags":["stm32mp1","yocto","linux"],"title":"在 STM32MP1 上使用 Yocto 建置 Linux 系統 3","uri":"https://e61983.github.io/2021-08-12-stm32mp-with-yocto-3/"},{"content":"前言 繼先前建立好基楚的系統後，我們已經可以順利開機，並從 NFS 載入 rootf filesystem。\n本文會接續之前建立的環境，開始加入自製的程式以及自訂的 Layer。\n主要內容 Recipe Recipe 是以 \u0026lt;APPLICATION_NAME\u0026gt;_\u0026lt;VERSION\u0026gt;.bb 的方式命名。裡面會包含這個 Package 該如何「穫取源始碼、Patch、編譯、安裝」的方法、它的授權方式以及它的相依套件/Package。\n為了簡化 Recipe 以及避免過多的重複，我們可以將共同的部份撰寫在 \u0026lt;APPLICATION\u0026gt;.inc 並在 Recipe 中引用。\n常見的配置項 DESCRIPTION\n說明、介紹此 Package\nHOMEPAGE\n如果此 Package 的專案有介紹網站的話，可以寫在此\nPRIORITY\n預設是: optional\nSECTION\n這個 Package 的分類。例: console/utils\nLICENSE\n這個 Package 的授權方式\nSRC_URL\n這個 Package 源始碼位置\n它的格式為: scheme://\u0026lt;ur\u0026gt;l;param1;param2\nscheme 可以是 https, git, svn, hg, ftp, file, \u0026hellip;\nSRC_URL[md5sum], SRC_URL[sha256sum]\n源始碼的檢查碼設置。\n例:\nSRC_URI = \u0026ldquo;http://example.com/src.tar.bz2;name=tarball\u0026quot;\nSRC_URI[tarball.md5sum] = \u0026ldquo;97b2c3fb082241ab5c56\u0026hellip;\u0026rdquo; git scheme:\ngit:\u0026lt;url\u0026gt;;protocol=\u0026lt;protocol\u0026gt;;branch=\u0026lt;branch\u0026gt; http,https,ftp:\nhttps://\u0026lt;url\u0026gt;\n也可以使用一些變數來設置位置，例: ${SOURCEFORGE_MIRROR}/\u0026lt;project-name\u0026gt;/${PN}-${PV}.tar.gz\n詳細資訊可以參考 meta/conf/bitbake.conf S\n獲取後、解壓縮後的源始碼路目錄。通常會配置為 ${WORKDIR}\n如果是使用 git 來獲取程式碼，則一定要設置成 ${WORKDIR}/git\nFILESPATH\n本機檔案的搜尋路徑。\n1 2 FILESPATH = \u0026#34;${@base_set_filespath([\u0026#34;${FILE_DIRNAME}/${BP}\u0026#34;, \u0026#34;${FILE_DIRNAME}/${BPN}\u0026#34;,\u0026#34;${FILE_DIRNAME}/files\u0026#34;], d)}\u0026#34; FILESOVERRIDES\n本機檔案的搜尋路徑。\n1 FILESOVERRIDES = \u0026#34;${TRANSLATED_TARGET_ARCH}:${MACHINEOVERRIDES}:${DISTROOVERRIDES}\u0026#34; LIC_FILES_CHKSUM\n1 2 3 LIC_FILES_CHKSUM = \u0026#34;file://gpl.txt;md5=393a5ca...\u0026#34; LIC_FILES_CHKSUM = \u0026#34;file://main.c;beginline=3;endline=21;md5=58e...\u0026#34; LIC_FILES_CHKSUM = \u0026#34;file://${COMMON_LICENSE_DIR}/MIT;md5=083...\u0026#34; DEPENDS\n在編譯時期的相依套件/Package。\n1 2 DEPENDS = \u0026#34;recipe-b\u0026#34; DEPENDS = \u0026#34;recipe-b (\u0026gt;= 1.2)\u0026#34; RDEPENDS\n在執行時期的相依套件/Package。\n1 2 RDEPENDS_${PN} = \u0026#34;recipe-b\u0026#34; RDEPENDS_${PN} = \u0026#34;recipe-b (\u0026gt; 1.2)\u0026#34; 常見的變數 PN\n表示 Package Name BPN\n移除 PN 的前綴與後綴。例: nativesdk- 或是 -native。 PV\n表示 Package Version PR\n表示 Package Revision。預設是: r0 BP\n表示 ${BPN}-${PV} WORKDIR\n表示 Recipe 工作時期的目錄 D\n表示安裝時的目標目錄 1 2 3 4 do_install() { install -d ${D}${bindir} install -m 0755 hello ${D}${bindir} } Task 在 Recipe 中有許的預設的 task，我們可以自訂、修改它們來滿足我們的需求。\ndo_fetch do_unpack do_patch do_configure do_compile do_install do_package do_rootfs 我們可以使用下列指令來顯示該 Recipe 有哪些 Task\nbitbake \u0026lt;recipe\u0026gt; -c listtasks 加入自訂的 Task 1 2 3 4 do_mkimage() { uboot-mkimage ... } addtask do_mkimage after do_compile before do_install Example Recipe 下列是一個 Recipe 的範例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 DESCRIPTION = \u0026#34;Hello world program\u0026#34; HOMEPAGE = \u0026#34;http://example.net/hello/\u0026#34; PRIORITY = \u0026#34;optional\u0026#34; SECTION = \u0026#34;examples\u0026#34; LICENSE = \u0026#34;CLOSED\u0026#34; LIC_FILES_CHKSUM = \u0026#34;\u0026#34; FILESOVERRIDES_prepend := \u0026#34;${THISDIR}/${PN}_${PV}:\u0026#34; SRC_URI = \u0026#34; \\ file://main.c \\ file://Makefile \\ \u0026#34; S = \u0026#34;${WORKDIR}\u0026#34; do_configure () { } do_compile () { oe_runmake } do_install () { oe_runmake install \u0026#39;DESTDIR=${D}\u0026#39; } 我們可以透過下列指令來看到編譯時期 pacakge 的配置。\n1 bitbake -e `\u0026lt;package\u0026gt;` 我們也可以使用下列指令來喚出編譯環境進行操作。\n1 bitbake -c devshell `\u0026lt;package\u0026gt;` 擴展 Recipe 通常不建議直接修改上游的配置，但常常我們又會遇到需要調整程式的需求。這時候我們可以使用 Recipe Extension (.bbappend)。\n它的命名方式為 \u0026lt;appliction\u0026gt;_\u0026lt;version\u0026gt;.bbappend\nrecipe-b_%.bbappend:\n這要的 % 為萬用字元，在此代表任意版本。\n1 2 3 4 FILESEXTRAPATHS_prepend := \u0026#34;${THISDIR}/files:\u0026#34; SRC_URI += \u0026#34;file://custom-modification-0.patch \\ file://custom-modification-1.patch \\ \u0026#34; 自訂 Virtual Packages 我們可以透過 PROVIDES = \u0026quot;virtual/\u0026lt;package\u0026gt;\u0026quot; 來表示。\nClass 我們可以提出共同的配置，撰寫成 .bbclass 。在不同的 Recipe 要使用時，就可以以 inherit \u0026lt;class\u0026gt; 來使用它。\n常見到地方有 Build System。例: cmake, make, autotools, \u0026hellip;。更多我們可以在 meta/classes 中找到\nBase Class 已包含了 fetch, unpack, compile, \u0026hellip; 等 Task。可以使用 oe_runmake 並透過 EXTRA_OEMAKE 來指定參數。\nKernel Class 用來建置 Linux Kernel 的 Class。它已配置了 PROVIDE，並且可以使用下列幾個變數:\nKERNEL_IMAGETYPE KERNEL_EXTRA_ARGS INITRAMFS_IMAGE Useradd Class 用來新增系統的使用者。在使用的時候必須指定 USERADD_PACKAGES，詳情可參考 useradd-example.bb。\n我們可以透過 USERADD_PARAM 與 GROUPADD_PARAM 來傳遞參數給 useradd 及 groupadd\n例:\n1 2 3 4 5 6 7 8 9 10 11 12 DESCRIPTION = \u0026#34;useradd class usage example\u0026#34; PRIORITY = \u0026#34;optional\u0026#34; SECTION = \u0026#34;examples\u0026#34; LICENSE = \u0026#34;MIT\u0026#34; SRC_URI = \u0026#34;file://file0\u0026#34; LIC_FILES_CHKSUM = \u0026#34;file://${COREBASE}/meta/files/common-licenses/MIT;md5=0835ade698e0bc...\u0026#34; inherit useradd USERADD_PACKAGES = \u0026#34;${PN}\u0026#34; USERADD_PARAM = \u0026#34;-u 1000 -d /home/user0 -s /bin/bash user0\u0026#34; do_install() { install -m 644 file0 ${D}/home/user0/ chown user0:user0 ${D}/home/user0/file0 } Layer Layer 是以 meta-\u0026lt;LAYER_NAME\u0026gt; 的方式命名。裡面會包含這個一個或數個 Recipe。\nBitbake 會獲取 ${BUILDDIR}/conf/bblayers.conf 中每個 Layer 的配置，進而開始建置系統。\n所以，如果我們想要加入 Layer 時，必須將其加入至 BBLAYERS 變數中。\nmeta-bootlinlabs 建立 meta-bootlinlabs 並加入 BBLAYERS 中。\n1 2 3 cd ${BUILDDIR} bitbake-layers create-layer -p 7 ../meta-bootlinlabs bitbake-layers add-layer ../meta-bootlinlabs/ 加入 recipe-ninvaders 1 2 3 4 5 pushd ../meta-bootlinlabs mkdir -p recipes-ninvaders/ninvaders recipetool create -o recipes-ninvaders/ninvaders/ninvaders_git.bb https://github.com/TheZ3ro/ninvaders popd bitbake ninvaders 筆者在編譯時遇到了下列錯誤，如果有同學也遇到相同的問題，可以進行下列提到的修改。\nERROR: ninvaders-1.0+gitAUTOINC+c6ab4117ba-r0 do_compile: oe_runmake failed\nERROR: ninvaders-1.0+gitAUTOINC+c6ab4117ba-r0 do_compile: Execution of \u0026lsquo;/home/yuan/workspace/yocto-stm32-labs/build/tmp/work/cortexa7t2hf-neon-vfpv4-poky-linux-gnueabi/ninvaders/1.0+gitAUTOINC+c6ab4117ba-r0/temp/run.do_compile.2732811\u0026rsquo; failed with exit code 1:\nmake: *** No rule to make target \u0026lsquo;globals.o\u0026rsquo;, needed by \u0026rsquo;nInvaders\u0026rsquo;. Stop.\nWARNING: exit code 1 from a shell command.\nninvaders_git.bb:\n1 2 - inherit autotools + inherit autotools-brokensep The problem is most likely that you\u0026rsquo;re not using automake but the\ngenerated recipe (would have been useful to include that) is using the\nautotools class, which assumes correct use of both autoconf and\nautomake. Specifically, your hand-written Makefile doesn\u0026rsquo;t handle\nout-of-tree builds.\nSource: [yocto] Adding nInvaders game package recipe\n將 ninvaders 加入 root filesystem 中 重新編譯後，記得要更新 NFS 分享目錄\n1 2 echo \u0026#39;IMAGE_INSTALL_append = \u0026#34; ninvaders\u0026#34;\u0026#39; bitbake core-image-miminal 接著重新啟動 STM32MP1 之後，執行 nInvaders\nnInvaders 執行結果\n小結 因為筆者手邊沒有 Nunchuk ，所以也就沒有進行 Lab 5 了。\n有興趣的同學，再自己玩玩看囉!\n參考連結 OpenEmbedded Layer Index TheZ3ro/ninvaders Bootlin/Yocto with STM32 Bootlin/Yocto with STM32 Lab ","description":"","id":21,"section":"posts","tags":["stm32mp1","yocto","linux"],"title":"在 STM32MP1 上使用 Yocto 建置 Linux 系統 2","uri":"https://e61983.github.io/2021-08-12-stm32mp-with-yocto-2/"},{"content":"前言 手邊有一片很久沒有動過的 STM32MP157。剛好最近工作上需要在 imx8 進行開發。本文會照著 Bootlin 的課程進行實作 [2],一方面了解 Yocto 要如何使用，另一方面順便藉此先練練手。\n主要內容 環境 本文的實作環境是使用 Ubuntu 20.04.2 LTS 做為 Host，使用的網段是在 10.1.100.0/24 內。\n準備 Bootlin 的課程資料 下載 bootlin 課程之 Lab 資料\n1 2 3 4 5 6 7 cd ${HOME} # 下載 Lab 資料 wget https://bootlin.com/doc/training/yocto-stm32/yocto-stm32-labs.tar.xz # 解壓縮 tar xvf yocto-stm32-labs.tar.xz 安裝 Yocto 的相依套件 1 sudo apt install -y bc build-essential chrpath cpio diffstat gawk git python texinfo wget gdisk 筆者在編譯映像檔時，遇到了 openssl/ssl.h' file not found 的問題，所以輸入下列指令進行安裝。\n1 sudo apt install -y libssl-dev 建置 Yocto 環境 1 2 3 4 5 6 pushd ${HOME}/yocto-stm32-labs git clone -b dunfell-23.0.7 git://git.yoctoproject.org/poky.git popd git clone -b dunfell git://git.openembedded.org/meta-openembedded git clone -b dunfell https://github.com/STMicroelectronics/meta-st-stm32mp.git # cd meta-st-stm32mp \u0026amp;\u0026amp; git checkout a95cc1ec39b60a1dc50d0902c91675935959e6d2 初始化 Yocto 環境\n1 2 cd ${HOME}/yocto-stm32-labs source poky/oe-init-build-env 加入 STM32MP1 的 BSP\n1 2 3 4 5 6 7 # pwd # ${HOME}/yocto-stm32-labs/poky/oe-init-build-env/build # 加入 stm32mp 相關的層 bitbake-layers add-layer ../meta-openembedded/meta-oe bitbake-layers add-layer ../meta-openembedded/meta-python bitbake-layers add-layer ../meta-st-stm32mp 修改 Yocto 的配置檔 1 2 # 修改目標機器 sed -i \u0026#39;s/^MACHINE.*/MACHINE ?= \u0026#34;stm32mp1\u0026#34;/g\u0026#39; conf/local.conf 建置映像檔 1 bitbake core-image-minimal 下列是 conf/local.conf 常會配置的幾個配置項\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 下載路徑 DL_DIR # 編譯結果快取 SSTATE_DIR # Bitbake 同時跑多少個 Task BB_NUMBER_THREADS # 編譯時跑多少個執行緒 PARALLEL_MAKE # 目標機器 MACHINE 建置用於 SD Card 的映像檔 1 2 3 ${BUILDDIR}/tmp/deploy/images/stm32mp1/scripts/create_sdcard_from_flashlayout.sh ../flashlayout_core-image-minimal/trusted/FlashLayout_sdcard_stm32mp157f-dk2-trusted.tsv # 產生 *.raw 於 ${BUILDDIR}/tmp/deploy/images/stm32mp1 將映像檔寫入 SD Card 中 1 2 3 4 # 插入 SD Card 到電腦中 sudo dd if=FlashLayout_sdcard_stm32mp157f-dk2-trusted.raw of=/dev/mmcblk0 bs=8M status=progress conv=fdatasync # or #sudo dd if=FlashLayout_sdcard_stm32mp157f-dk2-trusted.raw | pv -s ${IMAGE_SIZE} | dd of=/dev/mmcblk0 bs=4096 \u0026amp;\u0026amp; sync 測試 接上 ST-LINK 之後，在電腦開啟終端機\n接上 ST-Link\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 參考自己電腦實際認到的裝置號 screen /dev/${SERIAL_PORT} 115200 # 使用 root 登入 Poky (Yocto Project Reference Distro) 3.1.7 stm32mp1 /dev/ttySTM0 # 結果 # stm32mp1 login: root # root@stm32mp1:~# uname -a # Linux stm32mp1 5.4.56 #1 SMP PREEMPT Wed Aug 5 07:59:52 UTC 2020 armv7l GNU/Linux # root@stm32mp1:~# # 使用 C-a C-k 離開 在STM32MP1 第一個 Linux 系統\n從 NFS 載入 Root Filesystem 為了在後續的開發中，可以不用一直拔拔插插 SD Card。我們要讓系統在開機後，從 NFS Server 下載 root filesystem。\n建置 NFS 環境 在我們的工作機上，安裝 NFS Server\n1 2 3 4 5 6 7 8 9 10 11 # 安裝 NFS Server sudo apt install -y nfs-kernel-server # 建立 NFS 分享路徑 sudo mkdir /nfs_shared # 配置 NFS Server 設定檔 echo \u0026#34;/nfs_shared *(insecure,rw,sync,no_root_squash,subtree_check)\u0026#34; \u0026gt;\u0026gt; /etc/exports # 啟動 NFS Server sudo systemctl enable nfs-kernel-server \u0026amp;\u0026amp; sudo systemctl restart nfs-kernel-server 解壓縮我們先前建立好的 root filesystem 到 NFS 分享目錄中。\n1 2 # 將先前我們建置好的 root filesystem 解壓縮至我自建立的 /nfs_shared 中 sudo tar xpf ${BUILDDIR}/tmp/deploy/images/stm32mp1/core-image-minimal-stm32mp1.tar.xz -C /nfs_shared/ 修改 U-boot 的開機選項 修改 SD Card 內 bootfs 分割區中的 mmc0_extlinux/stm32mp157f-dk2_extlinux.conf，在開機的過程中u-boot 會將參數傳遞給 kernel。有興趣的同學可以參考 nfs/nfsroot.txt\n1 APPEND root=/dev/nfs rw console=ttySTM0,115200 nfsroot=${serverip}:/nfs_shared,vers=3,tcp ip=dhcp:${serverip}:${gateway}:${netmask}:${hostname}:eth0 為什麼是 mmc0_extlinux/stm32mp157f-dk2_extlinux.conf 這個檔案呢 ?\n筆者現階段並沒有深究，相信隨著課程的進行。\n我們會知道的。\n重新開機之後，系統就會從 NFS 載入 root filesystem 了。\n從 NFS 載入 rootfilesystem\n使用 SSH 登入 加入 SSH Server 至系統中 修改 conf/local.conf ，在裡面加上 dropbear Package\n1 echo \u0026#39;IMAGE_INSTALL_append = \u0026#34; dropbear\u0026#34;\u0026#39; \u0026gt;\u0026gt; ${BUILDDIR}/conf/local.conf 重新編譯\n1 bitbake core-image-minimal 依照先前的步驟，重新解壓縮剛建立好的 root filesystem 到 NFS 分享目錄中。\n測試 STM32MP1 重新開機後，在 Host 端使用 ssh 指令進行連接。\n1 2 3 4 5 6 7 8 ssh root@${IP} # 結果 # ssh root@10.1.100.104 # The authenticity of host \u0026#39;10.1.100.104 (10.1.100.104)\u0026#39; can\u0026#39;t be established. # RSA key fingerprint is SHA256:cDpQ47v01ZUkm6GpUG29F+RPOHVV7EzfDA5z/A4bDv4. # Are you sure you want to continue connecting (yes/no/[fingerprint])? yes # Warning: Permanently added \u0026#39;10.1.100.104\u0026#39; (RSA) to the list of known hosts. 更多關於 conf/local.conf 通常會是以大寫表示，如: CONF_VERSION _append:\n在原本設定的 後方 增加新的設定值，如: IMAGE_INSTALL_append = \u0026quot; dropbear\u0026quot; _prepend:\n在原本設定的 前方 增加新的設定值，如: FILESEXTRAPATHS_prepend := \u0026ldquo;${THISDIR}/${PN}\u0026rdquo; _remove:\n用來移除當下設定值中的值，如: IMAGE_INSTALL_remove = \u0026ldquo;i2c-tools\u0026rdquo; _${MACHINE}:\n用來表示，如果當時的 MACHINE 與 _${MACHINE} 相符時，使用這個設定值。\n如: IMAGE_INSTALL_append_beaglebone = \u0026quot; i2c-tools\u0026quot;，當我們的 MACHINE 是 beaglebone 時，才會生效。\n如: IMAGE_INSTALL_beaglebone = \u0026ldquo;busybox i2c-tools\u0026rdquo;，當我們的 MACHINE 是 beaglebone 時，才會生效。 上述的操作也可以使用符號表示\n=\n使用這個變數時，會將其展開。 :=\n立即值。 +=\n與 _append 相同 (要加上空白)。 (盡量避免在 conf/local.conf 中使用) =+\n與 _prepend 相同 (要加上空白)。(盡量避免在 conf/local.conf 中使用) .=\n與 _append 相同 (不用加上空白)。 (盡量避免在 conf/local.conf 中使用) =.\n與 _prepend 相同 (不用加上空白)。 (盡量避免在 conf/local.conf 中使用) ?=\n如果先前給過值的話，使用先前的值。 ??=\n與 ?= 相同，但優先權更低。 虛擬 Package Virtual Package 會以 vitual/命名，但它是不是真的 Package 。\n假的\n常見的 virtual pacakge 有\nvirtual/bootloader: u-boot, u-boot-ti-staging, \u0026hellip; virtual/kernel: linux-yocto, linux-yocto-tiny, linux-ti-staging, \u0026hellip; virtual/libc: glibc, musl, newlib virtual/xserver: xserver-xorg 選擇 我們可以使用 PREFERRED_PROVIDER 來指定我們想要用的 Package。\n如: PREFERRED_PROVIDER_vritual/kernel ?= \u0026ldquo;linux-ti-staging\u0026rdquo;\n我們可以使用 PREFERRED_VERSION 來指定想使用的 Package 版本。\n如: PREFERRED_VERSION_python = \u0026ldquo;2.7.3\u0026rdquo; 或是 PREFERRED_VERSION_linux-yocto = \u0026ldquo;5.4.%\u0026rdquo;\nRoot Filesystem 我們可以使用 IMAGE_INSTALL 來指定哪些 Packages 要加入 root filesystem 中，並可以使用 RDEPENDS 來指定其相依 Packages. 我們也可以使用 PACKAGE_EXCLUDE 來過慮我們不想要的 Packages。\n小結 我們已經建立了基本的 STM32MP1 Linux 系統開發環境，接下來就要一邊玩 Yocto 一邊探索 STM32MP1 的週邊了。\n參考連結 STM32MP157F-DK2 Bootlin/Yocto with STM32 Bootlin/Yocto with STM32 Lab Wiki - STM32MP1 Distribution Package Kernel Document - nfsroot ","description":"","id":22,"section":"posts","tags":["stm32mp1","yocto","linux"],"title":"在 STM32MP1 上使用 Yocto 建置 Linux 系統","uri":"https://e61983.github.io/2021-08-11-stm32mp-with-yocto/"},{"content":"前言 最近剛好要更新地圖應用。先前是直接使用 Mapbox ，但覺得它的 Marker 操作起來不是很彈性。因緣際會下聽說了 Leaflet ，就來試看看吧。\n維基百科是這樣說的。\nLeaflet是一個開源的JavaScript庫，用於構建Web地圖應用。首次發布於2011年，2它支持大多數移動和桌面平台，支持HTML5和CSS3。\n主要內容 安裝方式 本文撰寫時會以 CDN 的方式引入 Leaflet.js，實際使用時筆者是會使用套件管理工具進行安裝。\n安裝方式:\n1 yarn add leaflet 使用 CDN 的方式:\n1 2 3 4 5 6 7 8 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/leaflet@1.7.1/dist/leaflet.css\u0026#34; integrity=\u0026#34;sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==\u0026#34; crossorigin=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;!-- Make sure you put this AFTER Leaflet\u0026#39;s CSS --\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/leaflet@1.7.1/dist/leaflet.js\u0026#34; integrity=\u0026#34;sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==\u0026#34; crossorigin=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 起手式 在網頁中加入\n1 \u0026lt;div id=\u0026#34;map\u0026#34; style=\u0026#34;width:95vw;height:95vh\u0026#34; /\u0026gt; 初始化地圖\n1 2 3 4 5 6 var map = L.map(\u0026#39;map\u0026#39;).setView([34.985851028839406, 135.75788488621308], 10); L.tileLayer(\u0026#39;https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}\u0026#39;, { foo: \u0026#39;bar\u0026#39;, attribution: \u0026#39;\u0026amp;copy; \u0026lt;a href=\u0026#34;https://www.openstreetmap.org/copyright\u0026#34;\u0026gt;OpenStreetMap\u0026lt;/a\u0026gt; contributors\u0026#39;, }).addTo(map); 我們的第一張地圖\n如果我們想要使用 Mapbox 的圖資，在已取得存取金鑰之後(Access Toekn)，可在建立 titleLayer 時改用下列方式初始化。\n1 2 3 4 5 6 7 8 9 10 var map = L.map(\u0026#39;map\u0026#39;).setView([34.985851028839406, 135.75788488621308], 10); L.tileLayer(\u0026#39;\u0026#39;https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token={accessToken}\u0026#39;, { attribution: \u0026#39;\u0026amp;copy; \u0026lt;a href=\u0026#34;https://www.mapbox.com/about/maps/\u0026#34;\u0026gt;Mapbox\u0026lt;/a\u0026gt; contributors\u0026#39; maxZoom: 18, zoomOffset: -1, tileSize: 512, id: \u0026#39;mapbox/streets-v11\u0026#39;, accessToken: token }).addTo(map); 使用 Mapbox 圖資\n如果想要移除預設的 zoom controller 可以在初始化的時候加上 zoomControl: false\n1 var map = L.map(\u0026#39;map\u0026#39;, {zoomControl: false}).setView([34.985851028839406, 135.75788488621308], 10); 加上 Marker 在 Leaflet 中加上 marker 就跟呼吸一樣自然。\n1 2 3 L.marker([35.04074994371372, 135.72932367775914]).addTo(map); L.marker([34.97374817523019, 135.77195253085293]).addTo(map); L.marker([34.99936852552379, 135.7854861479551]).addTo(map); 加上 marker\n如果想要改變樣式，可以透過 icon 或是 iconDiv 來更改。\n1 2 3 4 5 6 7 8 9 10 11 12 var myIcon = L.icon({ iconUrl: \u0026#39;marker.png\u0026#39;, iconSize: [100, 95], iconAnchor: [22, 94], popupAnchor: [-3, -76], shadowUrl: \u0026#39;my-icon-shadow.png\u0026#39;, shadowSize: [68, 95], shadowAnchor: [22, 94] }); L.marker([34.70432671595862, 135.50096236284378], { icon: myIcon }).addTo(map); 1 2 3 4 5 6 7 var myDivIcon = L.divIcon({ className:\u0026#39;my-div-icon-wrapper\u0026#39;, html:`\u0026lt;div\u0026gt;這是 Div Icon \u0026lt;/div\u0026gt;` }); L.marker([34.68985107822455, 135.5253549268327], { icon: myDivIcon }).addTo(map); 1 2 3 4 5 6 .my-div-icon-wrapper div{ width: 100px; background-color: #060390; color: #eee; text-align: center; } 加上 marker\n來畫線吧 1 2 3 4 5 6 7 8 9 var latlngs = [ [35.02537491062854, 135.7438607946139], [34.88948810597932, 135.8076289149232], [34.961035819215525, 135.65613226663768], [34.976863645786004, 135.82695459531024], [34.88036360232042, 135.7002729085305], [35.02537491062854, 135.7438607946139], ]; L.polyline(latlngs, {color: \u0026#39;red\u0026#39;}).addTo(map); 來個封印陣吧!\n群組化並加上控制項 我們可以把想要歸在一起的東西放到同一個群組，這樣在接下來要分層顯示的時候，會更簡便一些。\n讓我們稍微調整一下程式碼。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ... let layer1 = L.layerGroup([ L.marker([35.04074994371372, 135.72932367775914]), L.marker([34.97374817523019, 135.77195253085293]), L.marker([34.99936852552379, 135.7854861479551]) ]).addTo(map); ... let layer2 = L.layerGroup([ L.marker([34.70432671595862, 135.50096236284378], { icon: myIcon }), L.marker([34.68985107822455, 135.5253549268327], { icon: myDivIcon }) ]).addTo(map); ... let layer3= L.layerGroup([ L.polyline(latlngs, {color: \u0026#39;red\u0026#39;}) ]).addTo(map); 將我們群組化後的 Layer 加入控制項中。\n1 2 3 4 5 let controller = L.control.layers().addTo(map); controller.addOverlay(layer1,\u0026#34;Marker\u0026#34;); controller.addOverlay(layer2,\u0026#34;自定的Marker\u0026#34;); controller.addOverlay(layer3,\u0026#34;封印陣\u0026#34;); controller.expand(); 加入控制項\n補充一下，如果想移除各個 Layer 的話可以透過下列方式，移除\n1 2 3 4 5 6 7 8 9 10 map.value.eachLayer((layer) =\u0026gt; { if (layer instanceof L.Marker) { map.value.removeLayer(layer); } }); // or layer1.remove(); 20210808 新增 - geoJSON Layer 測試資料可以到政府開放資料平台取得。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 let data = {\u0026#34;type\u0026#34;:\u0026#34;FeatureCollection\u0026#34;, \u0026#34;features\u0026#34;: [ \u0026#34;type\u0026#34;:\u0026#34;Feature\u0026#34;,\u0026#34;geometry\u0026#34;:{\u0026#34;type\u0026#34;:\u0026#34;Polygon\u0026#34;,\u0026#34;coordinates\u0026#34;:[[[121.543841724,25.0449066970000,...................... ]]] ]} function onEachFeature(feature, layer) { if (feature.properties \u0026amp;\u0026amp; feature.properties.TOWNNAME) { layer.bindPopup(feature.properties.TOWNNAME); } } L.geoJSON(data, { onEachFeature: onEachFeature, filter: function(feature, layer) { return feature.properties.TOWNNAME == \u0026#39;大安區\u0026#39;; }, style: function(feature) { switch (feature.properties.TOWNNAME) { case \u0026#39;大安區\u0026#39;: return {color: \u0026#34;#00ff00\u0026#34;,weight:1}; default: return {color: \u0026#34;#333333\u0026#34;,weight:1,opacity:0.5 }; } } }).addTo(map); 使用 geolayer\n成果 小結 使用 Leaflet 之後，不管是在操作 Marker 還是要建立 Path 都變得更加容易了。只能說是相見恨晚!\n參考連結 Leafletjs Migrate Mapbox Static Title API Leaflet-providers preview ","description":"","id":23,"section":"posts","tags":["map","leaflet","geojson"],"title":"使用 Leaflet 地圖","uri":"https://e61983.github.io/2021-08-04-using-leaflet-map/"},{"content":"前言 今年的 COSCUP 因應 COVID-19 疫情，所以以線上直播的方式進行。本篇主要是記錄大會第二天有興趣的議程以及關鍵字。\n主要內容 細談 MySQL Replication 強項 References: MySQL Replication 主從式架構設定教學 MySQL 主從複製原理 資料庫也可以全年無休啦! 神奇的MySQL HA架構拯救你的資料庫! MySQL Cluster\nSQL Node 讀資料 Data Node 存資料 Management Node - 用來管理 NDB Cluster MGM:\nconfig.ini ndb_mgm Data/ SQL Node\n/etc/my.conf ndbd SQL\nsystemd start mysqld Node Group\n一般是異步\nndb 是同步的\nMaster 會傳 Log 給 Slave ，確認後會執行動作來進行同步。 References MySQL Cluster學習筆記 SignalR 整合 LINE，在LIFF裡建立一對一聊天管道 LIFF ( Line Front-end Framework ) SignalR Group References: SignalR MySQL 8 那麼久了，還沒開始用 window function 嗎？ 什麼是 Wndow Function 保留每一列的 Query 結果，但又有聚合的操作結果。 OVER (PARTITION BY contry)\n{ OVER (window_spec) | OVER window_name }\nQuery Rewrite\n使用 Qemu + Debian Linux 來進行嵌入式系統入門教學 Den U-Boot Linux Kernel Root File System References: 共筆 MySQL究極防禦工事(全自動化MHA機制) Proxy SQL Orchestrator 了解 Master - Slave 架構、同步機制 References: Slide 共筆 初試 Casbin - 快速搭建符合 99% 產品都需要的高彈性可維護之授權控制系統 Authen \u0026amp; Authorization Authen - 你是誰 Authorization - 你可以做什麼 權限管理方式 ACL (Accuess Control List) RBAC (Role-Base Access Control) Attribute-based access control Casbin PML Policy Storage References: casbin/casbin ory ory/oathkeeper MySQL 8.0的新SQL為開發者開啟一片天 Window Function History 4.1 B-Tree, R-Tree, Subquery, Prepaed Statement 5.0 Stored Routines, Views, XTranstion 5.1 Event, Row-Based replicatoion, Plugin API 5.5 Support Unicode 5.6 InnoDB Buffer Pool Instance, Memmcached API, GTID 5.7 JSON data type, CJK 檢索, online DDL, JSON Function 8.0 \u0026hellip; 帶您製作新潮、實用且開源的 LINE 電子名片與廣告傳單 Flex Message LIFF References: 不用寫程式也能做 LINE 數位版名片\ntaichunmin/liff-businesscard ","description":"","id":24,"section":"posts","tags":["mysql","acl","chatbot","liff","coscup"],"title":"COSCUP 2021 Day 2","uri":"https://e61983.github.io/2021-08-01-coscup-2021-day-2/"},{"content":"前言 今年的 COSCUP 因應 COVID-19 疫情，所以以線上直播的方式進行。本篇主要是記錄大會第一天有興趣的議程以及關鍵字。\nCOSCUP2021\n主要內容 Introduction to Transactional Memory and Its Implementation GCC Example:\n1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; int main() { int i = 0; __transaction_atomic { i++; } return 0; } 在編譯的時候要加上 -fgnu-tm\n1 gcc -fgnu-tm Reference Slide reborn2266/STM-Toy Learning go error handling design from open source “Values can be programmed, and since errors are values, errors can be programmed.” \u0026ndash;Rob Pike\nReferences: Don’t just check errors, handle them gracefully Errors are values A trip about how I contribute to LLVM - Douglas Chen References: Slide 從 Go 的 runtime 源碼發掘瘋狂的 slice 用法 References Slide Select, Manage, and Backport the Long-Term Stable Kernels Linux CIP\nReferences: 共筆 Slide Automotive Linux Cuju - 虛擬機容錯功能實作 References Cuju User authentication in Go Web Server Rainbow table attack 讓密碼安全性更高的方式 salt (建議32bit) pepper (secret salt) 加鹽的方式\npassword length: 10 ~ 64 OTP (Once Time Password) Time OTP SMS OTP Resources: \u0026ndash;have i been pwned? Let\u0026rsquo;s Publish a Collaborative e-Book for Linux Kernel References: 共筆 The Linux Kernel Module Programming Guide Original Guide 藉由實作多任務核心來體驗作業系統概念 Raspbootcom:\nraspbootcom\nEnable UART0 FIFO References: Slide DavidSpickett/ARMMultiTasking Raspbootcom 參考連結 TransactionalMemory Rpi-JTAG\n","description":"","id":25,"section":"posts","tags":["gcc","go","linux","coscup"],"title":"COSCUP 2021 Day 1","uri":"https://e61983.github.io/2021-07-31-coscup-2021-day-1/"},{"content":"前言 一般來說，如果想要調整 Linux Kernel 只要在終端機輸入 make menuconfig 這類的指令就可以了。但如果在不同的開發流程中，就不是這麼單純了。\n本文主要是針對 Yocto 開發流進行記錄，未來有機會的話，會再補充 buildroot 的開發方式。\n主要內容 下圖取自 Yocto 官網。圖中示表了，在 Yocto 環境中開發 Kernel 時的流程\nhttps://docs.yoctoproject.org/current/kernel-dev/intro.html\n接下來的內容，筆者已初始化完 Yocto 相關的環境變數。此步驟若不清楚，可參考 這裡\n找到 Kernel 來源 Kernel 的配置一般來說，都會放在 conf/machine/ 中，並且會配置 PREFERRED_PROVIDER_virtual/kernel 來指定使用的 kernel。所以我們可以直接以 */conf/machine/*.conf 來進行搜尋。\n1 find . -wholename \u0026#34;*/conf/machine/*.conf\u0026#34; 找尋 machine 配置檔\n以 qemuarm.conf 為例:\n在這份檔案中我們並沒有看到 PREFERRED_PROVIDER_virtual/kernel 的設定。所以我們要去查看它引入的文件。\nqemuarm.conf\n在 qemuarm.inc:22 ，我們看到它是配置為 linux-yocto\nqemuarm.inc\n接下來就是要去找到 linux-yocto 它的配置檔在哪裡了。\n通常它會被放在 recipes-kernel/linux 中，但我們還是可以直接以搜尋的方式找到它。\n1 find . -iname \u0026#34;linux-yocto*\u0026#34; 最後我們可以看 SRC_URL 所指定的位置，即是 Kernel 的來源。\n呼喚出熟悉的畫面 1 bitbake virtual/kernel -c menuconfig 製作 Configuration Fragment 執行下列指令來產生 configuration fragment。產生的檔案會放置在 ${WORKDIR}/fragment.cfg。\n而 ${WORKDIR} 的位置可參考手冊中註明的位置: ${TMPDIR}/work/${MULTIMACH_TARGET_SYS}/${PN}/${EXTENDPE}${PV}-${PR}。\n1 2 3 4 bitbake virtual/kernel -c diffconfig # 把透過 diffconfig 產生的 fragment.cfg 移過來 \u0008mv tmp/work/qemuarm-poky-linux-gnueabi/linux-yocto/5.4.129+gitAUTOINC+c5e5dc4e13_dfb9647332-r0/fragment.cfg my-local-version.cfg 從內容應該可以看出來，筆者只有修改了 local version 而已。\n1 CONFIG_LOCALVERSION=\u0026#34;-yuan\u0026#34; 接下來我們可以透過 recipetool 幫我們將 my-local-version.cfg 加入我們的 Layer中。\n1 recipetool appendsrcfile meta-first-layer linux-yocto my-local-version.cfg 重新編譯 kernel\n1 2 3 4 bitbake virtual/kernel # 重新編譯 Image bitbake core-image-minimal 使用 qemu 進行驗證\n1 runqemu qemuarm core-image-minimal nographic slirp 修改 LOCALVERSION 之後的結果\n寫在最後 筆者在驗證修改 LOCALVERSION 是否有修改成功時，返覆的使用下列指令進行確認。\n但時常會沒有修改成功。\n1 2 bitbake linux-yocto -c kernel_configme -f bitbake linux-yocto -c kernel_configcheck -f 若有發現原因，會再進行補充。\n補充說明 如果在執行 bitbake virtual/kernel -c menuconfig 遇到了下列錯誤，可以安裝 screen 或是 tmux 來解決此問題。\nTried the following commands:\ntmux split-window -c \u0026ldquo;{cwd}\u0026rdquo; \u0026ldquo;do_terminal\u0026rdquo;\ntmux new-window -c \u0026ldquo;{cwd}\u0026rdquo; -n \u0026ldquo;linux-imx Configuration\u0026rdquo; \u0026ldquo;do_terminal\u0026rdquo;\nxfce4-terminal -T \u0026ldquo;linux-imx Configuration\u0026rdquo; -e \u0026ldquo;do_terminal\u0026rdquo;\nterminology -T=\u0026ldquo;linux-imx Configuration\u0026rdquo; -e do_terminal mate-terminal \u0026ndash;disable-factory -t \u0026ldquo;linux-imx Configuration\u0026rdquo; -x do_terminal\nkonsole \u0026ndash;separate \u0026ndash;workdir . -p tabtitle=\u0026ldquo;linux-imx Configuration\u0026rdquo; -e do_terminal\ngnome-terminal -t \u0026ldquo;linux-imx Configuration\u0026rdquo; \u0026ndash; do_terminal\nxterm -T \u0026ldquo;linux-imx Configuration\u0026rdquo; -e do_terminal\nrxvt -T \u0026ldquo;linux-imx Configuration\u0026rdquo; -e do_terminal\ntmux new -c \u0026ldquo;{cwd}\u0026rdquo; -d -s devshell -n devshell \u0026ldquo;do_terminal\u0026rdquo;\nscreen -D -m -t \u0026ldquo;linux-imx Configuration\u0026rdquo; -S devshell do_terminal 安裝方式:\n1 sudo apt install -y tmux 小結 在 Yocto 環境中調整 Kernel 其實是有許多方法的，例: 使用自己指定的 Kernel Source、使用我們給定的 defconfig，或是使用 patch 等。\n而我們此次是透過給予 Configuration Fragments 的方式進行。\n未來若有使用到其他方式，會再額外撰寫記錄。\n參考連結 Yocto Project Linux - Kernel Development Manual Yocto How to config image through layer Bitbake append file to reconfigure kernel ","description":"","id":26,"section":"posts","tags":["yocto","linux","kernel"],"title":"在 Yocto 環境中調整 Linux Kernel","uri":"https://e61983.github.io/2021-07-30-yocto-kernel-menuconfig/"},{"content":" 前言 突然好奇，要如何在 Hugo 中使用外部資源。本文就先以最簡單的方式，使用 CDN 引入 Bootstrap。\n主要內容 在文中貼上 Bootstrap 官網的 CDN 即可。\n1 2 3 \u0026lt;link href=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; integrity=\u0026#34;sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js\u0026#34; integrity=\u0026#34;sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 接著就可以開始使用了。\n下列以幻燈片作為範例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;div id=\u0026#34;carouselExampleIndicators\u0026#34; class=\u0026#34;carousel slide\u0026#34; data-bs-ride=\u0026#34;carousel\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;carousel-indicators\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; data-bs-target=\u0026#34;#carouselExampleIndicators\u0026#34; data-bs-slide-to=\u0026#34;0\u0026#34; class=\u0026#34;active\u0026#34; aria-current=\u0026#34;true\u0026#34; aria-label=\u0026#34;Slide 1\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; data-bs-target=\u0026#34;#carouselExampleIndicators\u0026#34; data-bs-slide-to=\u0026#34;1\u0026#34; aria-label=\u0026#34;Slide 2\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; data-bs-target=\u0026#34;#carouselExampleIndicators\u0026#34; data-bs-slide-to=\u0026#34;2\u0026#34; aria-label=\u0026#34;Slide 3\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;carousel-inner\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;carousel-item active\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://picsum.photos/1024/800?random=1\u0026#34; class=\u0026#34;d-block w-100\u0026#34; alt=\u0026#34;demo image 1\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;carousel-item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://picsum.photos/1024/800?random=2\u0026#34; class=\u0026#34;d-block w-100\u0026#34; alt=\u0026#34;demo image 2\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;carousel-item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://picsum.photos/1024/800?random=3\u0026#34; class=\u0026#34;d-block w-100\u0026#34; alt=\u0026#34;demo image 3\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button class=\u0026#34;carousel-control-prev\u0026#34; type=\u0026#34;button\u0026#34; data-bs-target=\u0026#34;#carouselExampleIndicators\u0026#34; data-bs-slide=\u0026#34;prev\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;carousel-control-prev-icon\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;visually-hidden\u0026#34;\u0026gt;Previous\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;carousel-control-next\u0026#34; type=\u0026#34;button\u0026#34; data-bs-target=\u0026#34;#carouselExampleIndicators\u0026#34; data-bs-slide=\u0026#34;next\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;carousel-control-next-icon\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;visually-hidden\u0026#34;\u0026gt;Next\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; Previous Next 小結 使用 CDN 就是如此的樸實無華好上手呀~\n參考連結 Bootstrap 5 Offical ","description":"","id":27,"section":"posts","tags":["bootstrap","web"],"title":"要如何在Hugo 中使用Bootstrap ?","uri":"https://e61983.github.io/2021-07-28-using-bootstrap-with-hugo/"},{"content":"前言 在準備完開發環境之後，接下來就要開始加上我們的設定、服務或是應用了。\n主要內容 在進行下列操作前，我們需要先初始化 Yocto 環境，如果還不知道要如何進行的同學，可以參考這邊。\n建立我們的 \u0026ldquo;層\u0026rdquo; 建議是將我們的 Layer 放在建置資料夾( first-build )的外面。所以我們將在它的上一層目錄建立我們的 Layer meta-first-layer。\n1 2 3 4 cd .. ls # first-build poky bitbake-layers create-layer meta-first-layer ls # first-build meta-first-layer poky 加入我們的 \u0026ldquo;層\u0026rdquo; 在建置資料夾( first-build ) 中執行下列指令，它會幫我們更新 conf/bblayer.bb 的內容。\n1 2 cd first-build bitbake-layers add-layer ../meta-first-layer Recipes-example 我們在建立 meta-first-layer 時，bitbake-layers 會順便幫我們建立 recipes-example。\n我們可以透過下列指令，看到它的輸出結果。\n1 bitbake example 執行結果:\n執行結果\n建立我們的 Recipes-Hello Yocto 專案提供了許多便捷的工具，其中 recipetool 與 devtool 便是與 Recipes 較為相關。\n接下來我們將會使用 recipetool 來建立我們的 Recipes。\n建立 recipes-hello 資料夾，並在 files 中放入我們的源始碼。\n1 2 mkdir -p recipes-hello/hello/files cd recipes-hello/hello main.c:\n1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { printf(\u0026#34;Hello\\n\u0026#34;); return 0; } Makefile:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 SRCS := main.c OBJS := $(SRCS:.c=.o) bindir ?= /usr/bin TARGET := hello all: $(TARGET) %.o : %.c $(CC) -c $\u0026lt; -o $@ ${LDFLAGS} $(TARGET) : $(OBJS) $(CC) $^ -o $@ ${LDFLAGS} install: install -d $(DESTDIR)$(bindir) install -m 755 $(TARGET) $(DESTDIR)$(bindir)/ 使用 recipetool 建立 recipe\n1 recipetool create -o hello_0.1.bb files 修改產生出的 hello_0.1.bb\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 LICENSE = \u0026#34;CLOSED\u0026#34; LIC_FILES_CHKSUM = \u0026#34;\u0026#34; SRC_URI = \u0026#34; \\ file://main.c \\ file://Makefile \\ \u0026#34; S = \u0026#34;${WORKDIR}\u0026#34; do_configure () { } do_compile () { oe_runmake } do_install () { oe_runmake install \u0026#39;DESTDIR=${D}\u0026#39; } 回到 first-build 進行測試\n1 bitbake hello 可以正常的進行編譯，但在最後出現了問題。\nERROR: hello-0.1-r0 do_package_qa: QA Issue: File /usr/bin/hello in package hello doesn\u0026rsquo;t have GNU_HASH (didn\u0026rsquo;t pass LDFLAGS?) [ldflags]\nERROR: hello-0.1-r0 do_package_qa: QA run found fatal errors. Please consider fixing them.\nERROR: Logfile of failure stored in: /home/yuan/first-build/tmp/work/cortexa7t2hf-neon-vfpv4-poky-linux-gnueabi/hello/0.1-r0/temp/log.do_package_qa.2726283\nERROR: Task (/home/yuan/meta-first-layer/recipes-hello/hello/hello_0.1.bb:do_package_qa) failed with exit code \u0026lsquo;1\u0026rsquo; 參考這篇文章\u0008修改 hello_0.1.bb\n1 2 3 4 5 6 do_install () { oe_runmake install \u0026#39;DESTDIR=${D}\u0026#39; } + + INSANE_SKIP_${PN} = \u0026#34;ldflags\u0026#34; + INSANE_SKIP_${PN}-dev = \u0026#34;ldflags\u0026#34; 建立我們的 image 在 recipes-hello 中建立 images 資料夾。\n1 2 3 mkdir -p recipes-hello/images cd recipes-hello/images cp ../../../poky/meta/recipes-core/images/core-image-minimal.bb hello-image.bb hello-image.bb:\n1 2 3 4 5 6 7 8 9 10 SUMMARY = \u0026#34;A hello image that just for testing our layer\u0026#34; LICENSE = \u0026#34;MIT\u0026#34; IMAGE_INSTALL = \u0026#34;packagegroup-core-boot ${CORE_IMAGE_EXTRA_INSTALL} hello\u0026#34; inherit core-image IMAGE_ROOTFS_SIZE ?= \u0026#34;8192\u0026#34; IMAGE_ROOTFS_EXTRA_SPACE_append = \u0026#34;${@bb.utils.contains(\u0026#34;DISTRO_FEATURES\u0026#34;, \u0026#34;systemd\u0026#34;, \u0026#34; + 4096\u0026#34;, \u0026#34;\u0026#34; ,d)}\u0026#34; 回到 first-build 進行測試\n1 2 bitbake hello-image runqemu hello-image nographic slirp 另一個建立 Recipes-hello 的方法 在工作目錄 ( first-build ) 使用 devtool 加入我們寫好的 hello 至 工作目錄中。\n1 devtool add hello ../hello 這個動作會幫我們在 conf/bblayer.bb 中加入 workspace 層，並建立 workspace/recipes/hello 資料夾。\n使用下列指令編譯 hello\n1 2 devtool build hello ls 可以發現它確實多了 Workspace Layer\n使用 devtool 建立臨時測試用的 image，並使用 qemu 進行驗證。\n1 2 devtool build-image core-image-minimal runqemu core-image-minimal nographic slirp 在測試沒有問題之後，再使用 devtool 將 hello 加入我們的 Layer\n1 devtool finish hello ../meta-first-layer 小結 我們已經建立了自己的 Layer、Recipe 以及 Image。 接下來我們就可以試著建立屬於我們的 Distribution 和 Machine 了。\n參考連結 Building your own recipes from first principles How to fix : ERROR: do_package_qa: QA Issue: No GNU_HASH in the elf binary Devtool Reference Yocto Manual ","description":"","id":28,"section":"posts","tags":["yocto"],"title":"Yocto First Layer","uri":"https://e61983.github.io/2021-07-28-yocto-first-layer/"},{"content":"前言 先前有接觸過 buildroot 這類的 Linux Distribution 工具，但一直沒有好好的整理起來。\n最近剛好有機會接觸 Yocto，打算在摸索的過程中一並記錄起來。\n主要內容 Yocto 專案 有關於 Yocto 專案的歴史就不多做介紹了，有興趣的同學可以到它的官網看看。\nYocto 官網畫面\n基本觀念 Yocto 開發流程\nMachine 相關的配置會放在 conf/machine/ 中。它用來描述與硬體有關的配置。通常包含: Kernel、Devices Tree、Bootloader。\nDistrobution 相關的配置會放在 conf/distro/ 中。它作為整個配置中最底層的部份。接下來的 Layer 都會以此為基礎往上疊加。通常它也訂定了此系統的 ABI 。\nImage 相關的配置會放在 recipes-*/images/ 中。它就是 rootfs。\nLayer 是由 Recipe 所組成，根據不同用途可以定義出BSP Layer, General Layer。\n一般來說我們會以 meta- 開頭作為 Layer 的命名。\nRecipe 是由一系列建構 Package 的指令所組成。描述了 Package 該如何取得源始碼、如何進行配置、如何進行編譯以及安裝的步驟。\nPackage 在 Yocto 中 Package 是代表 Recipe 的執行結果。\n建立 Yocto 環境 下載 Poky。\n等一下\u0026hellip; 怎麼突然就冒一個 poky 出來\n這個就先請同學自行去 Yocto 的官網看了\n1 2 mkdir yocto \u0026amp;\u0026amp; cd yocto git clone git://git.yoctoproject.org/poky.git 輸入下列指令初始化環境，它會幫我們建立 first-build 資料夾。並設置好相關的環境變數。\n1 source poky/oe-init-build-env first-build 開始第一個專案 輸入下列指令，就會開始進行編譯了。\n1 \u0008bitbake core-image-miminal 依照網路環境、編譯主機的不同，執行的時間會有所不同。但第一次都要蠻久的就是了。 在編譯完成之後，使用 qemu 來看看成果。\n1 runqemu qemuarm core-image-miminal nographic slirp 使用 root 登入\n登入畫面\n小結 本文記錄了 Yocto 開發時會需要知道的基楚資訊，未來在開發時，有發現不足的部份會再持續的補充。\n參考連結 Yocto Official Bootlin - Introduction to Yocto project ","description":"","id":29,"section":"posts","tags":["yocto","linux"],"title":"Yocto 基礎介紹","uri":"https://e61983.github.io/2021-07-27-yocto-introduction/"},{"content":"前言 手邊有一片很久沒有動過的 Raspberry Pi 3 B+。剛好最近工作上需要在 imx8 進行開發。藉此順便先練練手。\n主要內容 準備 Yocto 環境 建立我們要開發的資料夾 my-rpi，接下來我們都會在這個資料夾中進行操作。 下載 poky 。 1 2 mkdir my-rpi \u0026amp;\u0026amp; cd my-rpi git clone -b hardknott git://git.yoctoproject.org/poky.git 準備 meta-raspberrypi 層\n1 git clone -b hardknott git://git.yoctoproject.org/meta-raspberrypi 初始化開發環境\n1 source poky/oe-init-build-env build-rpi 加入 meta-raspibary 層\n1 bitbake-layers add-layer ../meta-raspberrypi 修改配置 1 2 3 4 5 6 sed -i \u0026#39;s/^MACHINE.*/MACHINE ?= \u0026#34;raspberrypi3\u0026#34;/g\u0026#39; conf/local.conf sed -i \u0026#39;/^#DL_DIR ?= \u0026#34;${TOPDIR}\\/downloads\u0026#34;/ a DL_DIR ?= \\\u0026#34;${HOME}/yocto/downloads\u0026#34;\u0026#39; conf/local.conf sed -i \u0026#39;s/^PACKAGE_CLASSES.*/PACKAGE_CLASSES ?= \u0026#34;package_ipk\u0026#34;/g\u0026#39; conf/local.conf echo \u0026#39;RPI_USE_U_BOOT = \u0026#34;1\u0026#34;\u0026#39; \u0026gt;\u0026gt; conf/local.conf echo \u0026#39;ENABLE_UART = \u0026#34;1\u0026#34;\u0026#39; \u0026gt;\u0026gt; conf/local.conf 開始編譯 1 bitbake core-image-minimal 寫入 SD Card 1 2 bzip -Dk core-image-minimal-raspberrypi3.wic.bz2 sudo dd if=core-image-minimal-raspberrypi3.wic of=${SD_CARD} bs=40960 小結 編譯出來的系統已可以開始，並在UART 終端機看到開始時的輸出，以及可以使用root 進入系統。\n參考連結 Yocto official meta-raspberrypi Building Raspberry Pi Systems with Yocto ","description":"","id":30,"section":"posts","tags":["linux","yocto"],"title":"使用 Yocto 打造你的 Raspberry Pi 系統","uri":"https://e61983.github.io/2021-07-26-building-raspberry-pi-systems-with-yocto/"},{"content":"前言 以前有使用過 hexo 建立Blog，但一直沒有好好的經營。最近又有想要開始寫 Blog 的念頭。\n希望這一次，可以持續撰寫下去。\n主要內容 由於筆者是使用 MacBook 作為日常使用的工具，所以本文將以 Mac 環境進行筆記。\n安裝 Hugo 1 brew install hugo 建立網站 1 hugo new ${SITE_NAME} 撰寫文章 1 2 cd ${SITE_NAME} hugo new posts/my-first-post.md 設定佈景主題 1 2 git submodule add https://github.com/upagge/uBlogger.git themes/uBlogger echo \u0026#39;theme = \u0026#34;uBlogger\u0026#34;\u0026#39; \u0026gt;\u0026gt; config.toml 修改樣式 建立相關資料夾\n1 mkdir -p assets/css/ 加入自訂樣式\n1 2 3 4 code[class*=\u0026#34;language-\u0026#34;] { color: white; text-shadow: none; } 小結 這次只有進行簡易的設定，還有許多功能還未探索。目前打算先用一陣子，再看看還有什麼有趣的東西。\n參考連結 uBlogger offical website 第 12 屆 iT 邦幫忙鐵人賽 - Hugo 貼身打造個人部落格 系列 ","description":"","id":31,"section":"posts","tags":["go","web","markdown"],"title":"打造自己的Blog","uri":"https://e61983.github.io/2021-07-26-first-hugo-website/"},{"content":"前言 使 GNU LD 輸出總共使用的記憶體大小與程式大小。\n主要內容 Makefile:\nLDFLAGS += -Wl,--print-memory-usage 參考連結 GNU LD - command options ","description":"","id":32,"section":"posts","tags":["linker"],"title":"GNU LD print memory usage","uri":"https://e61983.github.io/2018-02-06-ld-print-memory-usage/"},{"content":"前言 Generic 在C11上出現，我們可以透過實作出物件導向中的多型。要注意的是 Generic 是在編譯時期運作的。\n主要內容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; void funci(int x) { printf(\u0026#34;func value = %d\\n\u0026#34;, x); } void funcc(char c) { printf(\u0026#34;func char = %c\\n\u0026#34;, c); } void funcdef(double v) { printf(\u0026#34;Def func\u0026#39;s value = %lf\\n\u0026#34;, v); } #define func(X) \\ _Generic((X), \\ int: funci, char: funcc, default: funcdef \\ )(X) int main() { func(1); func(\u0026#39;a\u0026#39;); func(1.3); return 0; } 在多個參數的使用上比較繁瑣，需要自行作每個參數的組合。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #define format2(x,y) _Generic((x), \\ char: _Generic((y), \\ char:\u0026#34;%c - %c\\n\u0026#34;, \\ char*:\u0026#34;%c - %s\\n\u0026#34;, \\ int:\u0026#34;%c - %d\\n\u0026#34;, \\ default:\u0026#34;error\\n\u0026#34; \\ ), \\ char*: _Generic((y), \\ char:\u0026#34;%s - %c\\n\u0026#34;, \\ char*:\u0026#34;%s - %s\\n\u0026#34;, \\ int:\u0026#34;%s - %d\\n\u0026#34;, \\ default:\u0026#34;error\\n\u0026#34; \\ ), \\ int: _Generic((y), \\ char:\u0026#34;%d - %c\\n\u0026#34;, \\ char*:\u0026#34;%d - %s\\n\u0026#34;, \\ int:\u0026#34;%d - %d\\n\u0026#34;, \\ default:\u0026#34;error\\n\u0026#34; \\ ), \\ default:\u0026#34;error\\n\u0026#34; \\ ) #define print2(x, y) printf(format2(x,y),x,y) int main(int argc, char **argv) { printf(\u0026#34;test 2 parameters\\n\u0026#34;); print2(3, \u0026#39;c\u0026#39;); return 0; } ","description":"","id":33,"section":"posts","tags":["c11"],"title":"C11 Generic Selections","uri":"https://e61983.github.io/2017-10-18-c11-generic-selections/"}]