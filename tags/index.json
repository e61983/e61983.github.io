[{"content":"前言 先前有接觸過 buildroot 這類的 Linux Distribution 工具，但一直沒有好好的整理起來。\n最近剛好有機會接觸 Yocto，打算在摸索的過程中一並記錄起來。\n主要內容 Yocto 專案 有關於 Yocto 專案的歴史就不多做介紹了，有興趣的同學可以到它的官網看看。\n Yocto 官網畫面\n  基本觀念  Yocto 開發流程\n  Machine 相關的配置會放在 conf/machine/ 中。它用來描述與硬體有關的配置。通常包含: Kernel、Devices Tree、Bootloader。\nDistrobution 相關的配置會放在 conf/distro/ 中。它作為整個配置中最底層的部份。接下來的 Layer 都會以此為基礎往上疊加。通常它也訂定了此系統的 ABI 。\nImage 相關的配置會放在 recipes-*/images/ 中。它就是 rootfs。\nLayer 是由 Recipe 所組成，根據不同用途可以定義出BSP Layer, General Layer。\n一般來說我們會以  meta- 開頭作為 Layer 的命名。\nRecipe 是由一系列建構 Package 的指令所組成。描述了 Package 該如何取得源始碼、如何進行配置、如何進行編譯以及安裝的步驟。\nPackage 在 Yocto 中 Package 是代表 Recipe 的執行結果。\n 建立 Yocto 環境 下載 Poky。\n 等一下\u0026hellip; 怎麼突然就冒一個 poky 出來\n這個就先請同學自行去 Yocto 的官網看了\n 1 2  mkdir yocto \u0026amp;\u0026amp; cd yocto git clone git://git.yoctoproject.org/poky.git   輸入下列指令初始化環境，它會幫我們建立 first-build 資料夾。並設置好相關的環境變數。\n1  source poky/oe-init-build-env first-build   開始第一個專案 輸入下列指令，就會開始進行編譯了。\n1  \u0008bitbake core-image-miminal   依照網路環境、編譯主機的不同，執行的時間會有所不同。但第一次都要蠻久的就是了。  在編譯完成之後，使用 qemu 來看看成果。\n1  runqemu qemuarm core-image-miminal nographic slirp   使用 root 登入\n 登入畫面\n  小結 本文記錄了 Yocto 開發時會需要知道的基楚資訊，未來在開發時，有發現不足的部份會再持續的補充。\n參考連結  Yocto Official Bootlin - Introduction to Yocto project ","description":"","id":0,"section":"posts","tags":["yocto","linux"],"title":"Yocto 基礎介紹","uri":"https://e61983.github.io/2021-07-27-yocto-introduction/"},{"content":"前言 手邊有一片很久沒有動過的 Raspberry Pi 3 B+。剛好最近工作上需要在 imx8 進行開發。藉此順便先練練手。\n主要內容 準備 Yocto 環境  建立我們要開發的資料夾 my-rpi，接下來我們都會在這個資料夾中進行操作。 下載 poky 。  1 2  mkdir my-rpi \u0026amp;\u0026amp; cd my-rpi git clone -b hardknott git://git.yoctoproject.org/poky.git   準備 meta-raspberrypi 層\n1  git clone -b hardknott git://git.yoctoproject.org/meta-raspberrypi   初始化開發環境\n1  source poky/oe-init-build-env build-rpi   加入 meta-raspibary 層\n1  bitbake-layers add-layer ../meta-raspberrypi   修改配置 1 2 3 4 5 6  sed -i \u0026#39;s/^MACHINE.*/MACHINE ?= \u0026#34;raspberrypi3\u0026#34;/g\u0026#39; conf/local.conf sed -i \u0026#39;/^#DL_DIR ?= \u0026#34;${TOPDIR}\\/downloads\u0026#34;/ a DL_DIR ?= \\\u0026#34;${HOME}/yocto/downloads\u0026#34;\u0026#39; conf/local.conf sed -i \u0026#39;s/^PACKAGE_CLASSES.*/PACKAGE_CLASSES ?= \u0026#34;package_ipk\u0026#34;/g\u0026#39; conf/local.conf echo \u0026#39;RPI_USE_U_BOOT = \u0026#34;1\u0026#34;\u0026#39; \u0026gt;\u0026gt; conf/local.conf echo \u0026#39;ENABLE_UART = \u0026#34;1\u0026#34;\u0026#39; \u0026gt;\u0026gt; conf/local.conf   開始編譯 1  bitbake core-image-minimal   寫入 SD Card 1 2  bzip -Dk core-image-minimal-raspberrypi3.wic.bz2 sudo dd if=core-image-minimal-raspberrypi3.wic of=${SD_CARD} bs=40960   小結 編譯出來的系統已可以開始，並在UART 終端機看到開始時的輸出，以及可以使用root 進入系統。\n參考連結  Yocto official meta-raspberrypi Building Raspberry Pi Systems with Yocto ","description":"","id":1,"section":"posts","tags":["linux","yocto"],"title":"使用 Yocto 打造你的 Raspberry Pi 系統","uri":"https://e61983.github.io/2021-07-26-building-raspberry-pi-systems-with-yocto/"},{"content":"前言 以前有使用過 hexo 建立Blog，但一直沒有好好的經營。最近又有想要開始寫 Blog 的念頭。\n希望這一次，可以持續撰寫下去。\n主要內容 由於筆者是使用 MacBook 作為日常使用的工具，所以本文將以 Mac 環境進行筆記。\n安裝 Hugo 1  brew install hugo   建立網站 1  hugo new ${SITE_NAME}   撰寫文章 1 2  cd ${SITE_NAME} hugo new posts/my-first-post.md   設定佈景主題 1 2  git submodule add https://github.com/upagge/uBlogger.git themes/uBlogger echo \u0026#39;theme = \u0026#34;uBlogger\u0026#34;\u0026#39; \u0026gt;\u0026gt; config.toml   修改樣式 建立相關資料夾\n1  mkdir -p assets/css/   加入自訂樣式\n1 2 3 4  code[class*=\u0026#34;language-\u0026#34;] { color: white; text-shadow: none; }   小結 這次只有進行簡易的設定，還有許多功能還未探索。目前打算先用一陣子，再看看還有什麼有趣的東西。\n參考連結  uBlogger offical website 第 12 屆 iT 邦幫忙鐵人賽 - Hugo 貼身打造個人部落格 系列 ","description":"","id":2,"section":"posts","tags":["go","web","markdown"],"title":"打造自己的Blog","uri":"https://e61983.github.io/2021-07-26-first-hugo-website/"},{"content":"前言 使 GNU LD 輸出總共使用的記憶體大小與程式大小。\n主要內容 Makefile:\nLDFLAGS += -Wl,--print-memory-usage 參考連結  GNU LD - command options ","description":"","id":3,"section":"posts","tags":["linker"],"title":"GNU LD print memory usage","uri":"https://e61983.github.io/2018-02-06-ld-print-memory-usage/"},{"content":"前言 Generic 在C11上出現，我們可以透過實作出物件導向中的多型。要注意的是 Generic 是在編譯時期運作的。\n主要內容 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;stdio.h\u0026gt;void funci(int x) { printf(\u0026#34;func value = %d\\n\u0026#34;, x); } void funcc(char c) { printf(\u0026#34;func char = %c\\n\u0026#34;, c); } void funcdef(double v) { printf(\u0026#34;Def func\u0026#39;s value = %lf\\n\u0026#34;, v); } #define func(X) \\ _Generic((X), \\ int: funci, char: funcc, default: funcdef \\ )(X) int main() { func(1); func(\u0026#39;a\u0026#39;); func(1.3); return 0; }   在多個參數的使用上比較繁瑣，需要自行作每個參數的組合。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #define format2(x,y) _Generic((x), \\ char: _Generic((y), \\ char:\u0026#34;%c - %c\\n\u0026#34;, \\ char*:\u0026#34;%c - %s\\n\u0026#34;, \\ int:\u0026#34;%c - %d\\n\u0026#34;, \\ default:\u0026#34;error\\n\u0026#34; \\ ), \\ char*: _Generic((y), \\ char:\u0026#34;%s - %c\\n\u0026#34;, \\ char*:\u0026#34;%s - %s\\n\u0026#34;, \\ int:\u0026#34;%s - %d\\n\u0026#34;, \\ default:\u0026#34;error\\n\u0026#34; \\ ), \\ int: _Generic((y), \\ char:\u0026#34;%d - %c\\n\u0026#34;, \\ char*:\u0026#34;%d - %s\\n\u0026#34;, \\ int:\u0026#34;%d - %d\\n\u0026#34;, \\ default:\u0026#34;error\\n\u0026#34; \\ ), \\ default:\u0026#34;error\\n\u0026#34; \\ )  #define print2(x, y) printf(format2(x,y),x,y) int main(int argc, char **argv) { printf(\u0026#34;test 2 parameters\\n\u0026#34;); print2(3, \u0026#39;c\u0026#39;); return 0; }   ","description":"","id":4,"section":"posts","tags":["c11"],"title":"C11 Generic Selections","uri":"https://e61983.github.io/2017-10-18-c11-generic-selections/"}]